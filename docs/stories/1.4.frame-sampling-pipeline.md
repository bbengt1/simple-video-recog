# Story 1.4: Frame Sampling and Processing Pipeline

## Status
Draft

## Story
**As a** developer,
**I want** to implement configurable frame sampling to process every Nth frame,
**so that** I can optimize performance by reducing the frame processing rate while maintaining adequate coverage.

## Acceptance Criteria

1. Frame sampling logic implemented in core/pipeline.py with FrameSampler class
2. frame_sampling_rate parameter from configuration determines sampling (e.g., 10 = process every 10th frame)
3. FrameSampler.should_process(frame_count) returns True/False based on sampling rate
4. frame_count is continuously incrementing counter of total frames captured (not just processed)
5. Sampling applies AFTER motion detection: Sample from motion-triggered frames, not all frames
6. Processing pipeline orchestration (ProcessingPipeline class) coordinates: frame capture → motion detection → sampling → (future: object detection)
7. Pipeline maintains metrics: total_frames_captured, frames_with_motion, frames_sampled, frames_processed
8. Metrics accessible via get_metrics() method returning dictionary
9. Pipeline runs continuously in main thread, reading from frame queue populated by RTSP thread
10. Ctrl+C (SIGINT) cleanly stops pipeline: stops RTSP thread, processes remaining queued frames, logs final metrics
11. Unit tests verify sampling logic: rate=1 processes all frames, rate=10 processes every 10th, rate=100 processes every 100th
12. Integration test: Run pipeline with test video, verify metrics match expected values based on known motion events

## Tasks / Subtasks

- [ ] **Task 1: Create FrameSampler class structure** (AC: 1, 2, 3)
  - [ ] Create `core/pipeline.py` module file
  - [ ] Define `FrameSampler` class with constructor accepting `SystemConfig`
  - [ ] Add `__init__` method with dependency injection for config
  - [ ] Store frame_sample_rate from config as instance variable
  - [ ] Initialize frame counter for continuous counting
  - [ ] Add proper type hints and Google-style class docstring

- [ ] **Task 2: Implement should_process() method** (AC: 3, 4)
  - [ ] Implement `should_process(frame_count: int) -> bool` method
  - [ ] Logic: return (frame_count % frame_sample_rate) == 0
  - [ ] frame_count is continuously incrementing (passed from caller)
  - [ ] Add docstring with Args, Returns sections

- [ ] **Task 3: Create ProcessingPipeline class structure** (AC: 6, 7, 8)
  - [ ] Define `ProcessingPipeline` class in same module
  - [ ] Constructor accepts RTSPCameraClient, MotionDetector, FrameSampler, SystemConfig
  - [ ] Initialize metrics dictionary with counters: total_frames_captured, frames_with_motion, frames_sampled, frames_processed
  - [ ] Add get_metrics() method returning metrics dictionary
  - [ ] Add proper type hints and Google-style class docstring

- [ ] **Task 4: Implement pipeline orchestration logic** (AC: 5, 6, 9)
  - [ ] Implement `run() -> None` method as main processing loop
  - [ ] Loop continuously: get_frame() → detect_motion() → if motion: check sampling → if sampled: process frame
  - [ ] Update metrics counters appropriately in each step
  - [ ] Handle empty queue gracefully (continue loop)
  - [ ] Add docstring with processing flow description

- [ ] **Task 5: Implement graceful shutdown** (AC: 10)
  - [ ] Add signal handler for SIGINT (Ctrl+C)
  - [ ] Implement shutdown flag and cleanup logic
  - [ ] Process remaining frames in queue before shutdown
  - [ ] Log final metrics before exit
  - [ ] Ensure RTSP thread is stopped cleanly

- [ ] **Task 6: Add unit tests for FrameSampler** (AC: 11)
  - [ ] Create `tests/unit/test_pipeline.py` file
  - [ ] Test 1: `test_frame_sampler_rate_1()` - rate=1 processes all frames
  - [ ] Test 2: `test_frame_sampler_rate_10()` - rate=10 processes every 10th frame
  - [ ] Test 3: `test_frame_sampler_rate_100()` - rate=100 processes every 100th frame
  - [ ] Test 4: `test_frame_sampler_continuous_counting()` - frame_count increments continuously
  - [ ] Use pytest fixtures for sample config

- [ ] **Task 7: Add unit tests for ProcessingPipeline** (AC: 7, 8)
  - [ ] Test 5: `test_processing_pipeline_metrics()` - verify metrics tracking
  - [ ] Test 6: `test_processing_pipeline_get_metrics()` - verify get_metrics() returns correct dictionary
  - [ ] Test 7: `test_processing_pipeline_integration()` - mock components, verify orchestration
  - [ ] Use mocks for RTSPCameraClient, MotionDetector, FrameSampler

- [ ] **Task 8: Add integration test** (AC: 12)
  - [ ] Create `tests/integration/test_pipeline_integration.py`
  - [ ] Test uses test video file with known motion events
  - [ ] Verify metrics match expected values (frames captured, motion detected, sampled, processed)
  - [ ] Test runs full pipeline with real components (not mocks)

## Dev Notes

### Previous Story Insights

From Story 1.3 (Motion Detection Implementation):
- MotionDetector.detect_motion() returns (has_motion, confidence, motion_mask)
- Motion detection completes in <50ms per frame on M1
- SystemConfig includes frame_sample_rate parameter (default: 5)
- Project uses dependency injection pattern throughout
- Google-style docstrings required for all public methods
- [Source: docs/stories/1.3.motion-detection.md#Dev Agent Record]

From Story 1.2 (RTSP Camera Connection):
- RTSPCameraClient provides continuous frame capture via background thread
- Frame queue (max 100) buffers frames between RTSP thread and main processing
- RTSP client handles reconnection with exponential backoff
- Frame format: numpy array (BGR), None when unavailable
- [Source: docs/stories/1.2.rtsp-camera-connection.md#Dev Agent Record]

### Pipeline Architecture

**Module Path:** `core/pipeline.py`

**Key Classes:**
- `FrameSampler`: Handles configurable frame sampling logic
- `ProcessingPipeline`: Orchestrates the complete processing workflow

**Processing Flow:**
1. RTSP thread continuously captures frames → frame_queue
2. Main thread reads from frame_queue
3. Motion detection on each frame
4. If motion detected: check sampling rate
5. If frame should be processed: run object detection (future)
6. Update metrics throughout

**Sampling Logic:**
- Applied AFTER motion detection (only sample motion-triggered frames)
- frame_sample_rate=1: process all motion frames
- frame_sample_rate=5: process every 5th motion frame
- frame_sample_rate=10: process every 10th motion frame

**Metrics Tracking:**
- total_frames_captured: All frames from RTSP (incremented by RTSP thread)
- frames_with_motion: Frames that passed motion detection
- frames_sampled: Frames that passed sampling filter
- frames_processed: Frames that completed full processing pipeline

[Source: docs/architecture/processing-pipeline.md]

### Testing Strategy

**Unit Tests:** Focus on individual component logic
- FrameSampler sampling algorithm
- ProcessingPipeline metrics tracking
- Component integration with mocks

**Integration Tests:** End-to-end pipeline validation
- Use test video with known motion events
- Verify complete metrics flow
- Validate performance and correctness

**Test Coverage Target:** ≥80% for core/ modules
**Test Framework:** pytest with fixtures and mocking

[Source: docs/architecture/test-organization.md]

### Configuration Parameters

**frame_sample_rate:** int (default: 5, range: 1-30)
- Controls processing frequency for motion-triggered frames
- Lower values = more processing (better coverage, higher CPU)
- Higher values = less processing (reduced coverage, lower CPU)

[Source: docs/architecture/systemconfig.md]

## Testing

### Unit Test Cases for FrameSampler
- Rate=1: frames 1,2,3,4,5 → process all (100%)
- Rate=5: frames 1,2,3,4,5 → process frame 5 only (20%)
- Rate=10: frames 1-20 → process frames 10,20 only (10%)
- Continuous counting: frame_count increments regardless of processing decision

### Unit Test Cases for ProcessingPipeline
- Metrics initialization: all counters start at 0
- Metrics updates: correct incrementing during processing
- Component integration: proper method calls and data flow
- Error handling: graceful handling of component failures

### Integration Test Scenarios
- Test video with 10 motion events, sample_rate=2
- Expected: 10 motion detected, 5 sampled, 5 processed
- Verify metrics match expected values
- Performance: <100ms per frame processing time

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-09 | 1.0 | Initial story draft created by Scrum Master | SM (Bob) |