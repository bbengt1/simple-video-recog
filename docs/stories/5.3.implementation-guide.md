# Story 5.3: Real-Time Event Streaming - Implementation Guide

**Quick Reference for Developers**

---

## ðŸŽ¯ Story Overview

**Goal:** Implement WebSocket endpoint for real-time event streaming to dashboard clients.

**Effort:** 7-9 hours (1 day)

**Priority:** HIGH (Enables live monitoring experience)

**Depends On:**
- Story 5.1 (FastAPI server)
- Story 5.2 (Event Pydantic models)

---

## ðŸ“‹ Pre-Implementation Checklist

Before you start, verify:

- [ ] Story 5.1 is complete (FastAPI server running)
- [ ] Story 5.2 is complete (Event API endpoints working)
- [ ] Event Pydantic model exists in `api/models.py`
- [ ] EventManager class exists in `core/event_manager.py`
- [ ] FastAPI server starts successfully
- [ ] Database contains events for testing
- [ ] Understanding of async/await in Python
- [ ] Understanding of WebSocket protocol basics

---

## ðŸš€ Quick Start (TDD Approach)

### 1. Create Test Files (10 min)

```bash
# Create test files
touch tests/api/test_websocket.py
touch tests/integration/test_websocket_flow.py
```

### 2. Write Failing Tests (30 min)

Copy test code from `docs/stories/5.3.story.md` section "Testing Requirements"

Run tests (should fail):
```bash
pytest tests/api/test_websocket.py -v
```

### 3. Implement Core Components (4-5 hours)

**Order of Implementation:**

1. **WebSocketManager** (`api/websocket.py`) - 45 min
   - Connection tracking (add, remove)
   - Broadcast logic
   - Heartbeat mechanism
   - Test: `pytest tests/api/test_websocket.py::test_websocket_connection`

2. **WebSocket Endpoint** (`api/routes/stream.py`) - 30 min
   - Create `/ws/events` endpoint
   - Handle connect/disconnect
   - Message handling (ping/pong)
   - Test: Manual connection with browser/websocat

3. **Heartbeat Logic** (`api/websocket.py`) - 20 min
   - Ping/pong messages
   - Automatic cleanup of dead connections
   - Test: Receive pings every 30 seconds

4. **EventManager Integration** (`core/event_manager.py`) - 45 min
   - Add websocket_manager parameter
   - Broadcast events in create_event()
   - Async broadcast call
   - Test: Events broadcast when created

5. **FastAPI App Integration** (`api/app.py`) - 15 min
   - Add stream router
   - Add startup/shutdown events
   - Heartbeat task startup
   - Test: Server starts with WebSocket support

### 4. Manual Testing (45 min)

```bash
# Terminal 1: Start web server
python web_server.py

# Terminal 2: Connect with websocat (install: brew install websocat)
websocat ws://localhost:8000/ws/events

# Expected: Receive ping message every 30 seconds
# {"type": "ping", "timestamp": "2025-11-10T..."}

# Terminal 3: Trigger event (run main.py or manually create event)
python main.py --dry-run

# Expected in Terminal 2: Receive event message
# {"type": "event", "data": {...}}
```

**Browser Console Test:**
```javascript
// Open http://localhost:8000 in browser
// Open DevTools Console (F12)
const ws = new WebSocket('ws://localhost:8000/ws/events');

ws.onopen = () => console.log('âœ“ WebSocket connected');

ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    console.log('Received:', message);
};

ws.onerror = (error) => console.error('WebSocket error:', error);

ws.onclose = () => console.log('WebSocket closed');

// Should see ping messages every 30 seconds
// Trigger an event and see it appear
```

### 5. Load Testing (30 min)

```bash
# Test with multiple concurrent connections
# Create test script: test_ws_load.py

import asyncio
import websockets
import json

async def connect_client(client_id):
    uri = "ws://localhost:8000/ws/events"
    async with websockets.connect(uri) as websocket:
        print(f"Client {client_id} connected")

        # Listen for messages for 60 seconds
        try:
            while True:
                message = await asyncio.wait_for(
                    websocket.recv(),
                    timeout=60
                )
                data = json.loads(message)
                print(f"Client {client_id} received: {data['type']}")
        except asyncio.TimeoutError:
            print(f"Client {client_id} timeout")

async def main():
    # Connect 100 clients
    tasks = [connect_client(i) for i in range(100)]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

### 6. Documentation (30 min)

- Update README with WebSocket endpoint docs
- Add WebSocket client example
- Document message formats

---

## ðŸ”§ Implementation Details

### Critical: Async Event Broadcasting

**Problem:** EventManager is sync, WebSocket broadcast is async

**Solution:** Use `asyncio.create_task()` for non-blocking broadcast

```python
# core/event_manager.py

def create_event(self, ...):
    # ... create event and persist to database ...

    # NEW: Broadcast to WebSocket (non-blocking)
    if self.websocket_manager:
        try:
            event_dict = event.model_dump(mode='json')

            # Create async task (doesn't block)
            import asyncio
            asyncio.create_task(
                self.websocket_manager.broadcast_event(event_dict)
            )

        except Exception as e:
            # WebSocket errors don't fail event creation
            logger.warning(f"WebSocket broadcast failed: {e}")
```

**Why?** EventManager runs in sync context (main.py), but WebSocket needs async.

---

### Critical: Connection Cleanup

**Problem:** Dead connections accumulate in memory

**Solution:** Automatic cleanup during broadcast

```python
# api/websocket.py

async def broadcast_event(self, event_data: dict):
    dead_connections = []

    async with self._lock:
        for connection_id, websocket in self.active_connections.items():
            try:
                await websocket.send_json(message)
            except Exception as e:
                # Mark for cleanup
                dead_connections.append(connection_id)

    # Clean up outside lock
    for connection_id in dead_connections:
        self.disconnect(connection_id)
```

**Why?** Failed sends indicate dead connections, must be removed.

---

### Critical: Thread-Safe Connection List

**Problem:** Multiple async tasks access connection list simultaneously

**Solution:** Use asyncio.Lock for thread safety

```python
# api/websocket.py

def __init__(self):
    self.active_connections: Dict[str, WebSocket] = {}
    self._lock = asyncio.Lock()  # Thread safety

async def broadcast_event(self, event_data: dict):
    async with self._lock:  # Acquire lock
        # Safe to access connections here
        for connection_id, websocket in self.active_connections.items():
            # ...
```

**Why?** Prevents race conditions when adding/removing connections.

---

### Critical: WebSocket in Separate Process

**Problem:** main.py and web_server.py are separate processes

**Solution:** WebSocket only works when web_server.py is running

```python
# main.py

# Try to get WebSocket manager (web server might not be running)
try:
    from api.routes.stream import get_websocket_manager
    ws_manager = get_websocket_manager()
    logger.info("WebSocket support enabled")
except Exception:
    ws_manager = None
    logger.info("WebSocket support disabled (web server not running)")

# EventManager works with or without WebSocket
event_manager = EventManager(
    db_manager=db_manager,
    json_logger=json_logger,
    txt_logger=txt_logger,
    websocket_manager=ws_manager  # Can be None
)
```

**Why?** System should work with just main.py (no web server required).

---

### Critical: Message Format Consistency

**Problem:** Different message types need consistent format

**Solution:** Standard message envelope

```python
# Event message
{
    "type": "event",
    "data": {
        "event_id": "evt_123",
        "timestamp": "2025-11-10T...",
        # ... full Event model ...
    }
}

# Ping message
{
    "type": "ping",
    "timestamp": "2025-11-10T..."
}

# Pong message (from client)
{
    "type": "pong",
    "timestamp": "2025-11-10T..."
}

# Error message
{
    "type": "error",
    "message": "Invalid message format"
}
```

**Why?** Frontend can parse messages consistently based on `type` field.

---

## âœ… Acceptance Criteria Checklist

### AC 1: WebSocket Endpoint
- [ ] Endpoint at `ws://localhost:8000/ws/events`
- [ ] Accepts connections from clients
- [ ] Validates origin (localhost only)
- [ ] 3-way handshake completes
- [ ] Multiple simultaneous connections supported

### AC 2: Connection Manager
- [ ] `WebSocketManager` class created
- [ ] Tracks active connections
- [ ] Adds clients on connect
- [ ] Removes clients on disconnect
- [ ] Thread-safe connection list

### AC 3: Event Broadcasting
- [ ] Events broadcast to all clients
- [ ] Message format: `{"type": "event", "data": {...}}`
- [ ] Event data matches Event model
- [ ] Broadcast latency <100ms
- [ ] Failed sends handled gracefully

### AC 4: EventManager Integration
- [ ] EventManager updated with WebSocket support
- [ ] WebSocket manager injected
- [ ] Publishing is optional (doesn't fail if None)
- [ ] No changes to database persistence
- [ ] Backward compatible

### AC 5: Connection Lifecycle
- [ ] Client connect logged
- [ ] Client disconnect logged
- [ ] Server shutdown closes all connections
- [ ] Heartbeat ping every 30 seconds
- [ ] Dead connections cleaned up automatically

### AC 6: Error Handling
- [ ] Connection errors logged
- [ ] Malformed messages logged and ignored
- [ ] Broadcast errors handled individually
- [ ] Dead connection cleanup automatic
- [ ] Error messages sent to client

### AC 7: Message Format
- [ ] Event messages valid JSON
- [ ] Error messages valid JSON
- [ ] Ping messages valid JSON
- [ ] Pong responses defined
- [ ] All messages have `type` field

### AC 8: Client Reconnection Support
- [ ] Server sends ping every 30 seconds
- [ ] Pong expected from client
- [ ] No message replay
- [ ] Connection ID logged
- [ ] Connection metrics tracked

### AC 9: Performance Requirements
- [ ] Broadcast latency <100ms
- [ ] Memory <10MB per 100 clients
- [ ] No memory leaks
- [ ] CPU overhead <2%
- [ ] 100 simultaneous connections supported

### AC 10: Integration with Story 5.2
- [ ] Uses Event Pydantic model
- [ ] No duplicate serialization code
- [ ] WebSocket route in same FastAPI app
- [ ] OpenAPI docs updated

### AC 11: Logging and Monitoring
- [ ] Connection events logged
- [ ] Broadcast logged at DEBUG
- [ ] Connection count tracked
- [ ] Errors logged at ERROR
- [ ] Request ID in log messages

### AC 12: Testing
- [ ] Unit tests for WebSocketManager
- [ ] Integration test for lifecycle
- [ ] Manual browser test
- [ ] Load test (100 connections)
- [ ] Reconnection test

---

## ðŸ§ª Testing Strategy

### Unit Tests (90 min, >80% coverage)

**Test File:** `tests/api/test_websocket.py`

**Key Tests:**
```bash
# Run WebSocket tests
pytest tests/api/test_websocket.py -v

# Check coverage
pytest tests/api/test_websocket.py --cov=api/websocket --cov-report=term-missing
```

**Coverage Targets:**
- api/websocket.py: >85%
- api/routes/stream.py: >80%

---

### Integration Tests (45 min)

**Test File:** `tests/integration/test_websocket_flow.py`

**Manual Integration Test:**
```bash
# Install websocat (WebSocket CLI client)
brew install websocat

# Terminal 1: Start web server
python web_server.py

# Terminal 2: Connect WebSocket client
websocat ws://localhost:8000/ws/events

# Should receive:
# {"type": "ping", "timestamp": "..."}

# Terminal 3: Create event (trigger from main.py or manually)
# Should receive in Terminal 2:
# {"type": "event", "data": {...}}
```

---

### Load Testing (30 min)

**Test:** 100 simultaneous connections

```python
# test_ws_load.py (create this file)
import asyncio
import websockets
import json
import time

async def client(client_id):
    uri = "ws://localhost:8000/ws/events"
    start_time = time.time()
    messages_received = 0

    try:
        async with websockets.connect(uri) as ws:
            print(f"âœ“ Client {client_id} connected")

            # Listen for 30 seconds
            while time.time() - start_time < 30:
                try:
                    message = await asyncio.wait_for(ws.recv(), timeout=1)
                    messages_received += 1
                except asyncio.TimeoutError:
                    pass

            print(f"âœ“ Client {client_id}: {messages_received} messages")

    except Exception as e:
        print(f"âœ— Client {client_id} failed: {e}")

async def main():
    print("Starting 100 WebSocket clients...")
    tasks = [client(i) for i in range(100)]
    await asyncio.gather(*tasks)
    print("All clients completed")

if __name__ == "__main__":
    asyncio.run(main())
```

Run:
```bash
python test_ws_load.py
```

**Expected Results:**
- All 100 clients connect successfully
- Each client receives ping messages
- Server memory usage <200MB
- Server CPU usage <5%

---

### Manual Testing Checklist (30 min)

- [ ] Start server: `python web_server.py`
- [ ] Connect with browser console (WebSocket API)
- [ ] Verify connection established
- [ ] Receive ping every 30 seconds
- [ ] Trigger event, verify received <1s
- [ ] Connect 3 clients simultaneously
- [ ] Verify all receive events
- [ ] Disconnect one client, others still work
- [ ] Restart server, client can reconnect
- [ ] Check logs for connection events
- [ ] Verify no memory leaks (30 min run)
- [ ] Check OpenAPI docs show WebSocket endpoint

---

## ðŸš¨ Common Issues & Solutions

### Issue 1: "WebSocket connection refused"

**Symptom:**
```javascript
// Browser console
WebSocket connection to 'ws://localhost:8000/ws/events' failed
```

**Diagnosis:**
```bash
# Check if web server is running
curl http://localhost:8000/api/health

# Check if WebSocket route exists
grep "ws/events" api/routes/stream.py
```

**Solution:**
- Ensure `python web_server.py` is running
- Verify stream router is included in `api/app.py`
- Check CORS settings allow WebSocket

---

### Issue 2: "Events not broadcasting"

**Symptom:**
- WebSocket connected
- Pings received
- Events created in main.py
- But no events received on WebSocket

**Diagnosis:**
```bash
# Check logs for broadcast messages
grep "broadcast" logs/web_server.log

# Check if EventManager has WebSocket manager
grep "WebSocket support" logs/app.log
```

**Common Causes:**
- main.py and web_server.py are separate processes (can't share WebSocket)
- EventManager doesn't have websocket_manager parameter
- Broadcast call failing silently

**Solution:**
For Story 5.3, WebSocket only works when web_server.py is running separately. main.py cannot broadcast directly. This is expected behavior.

**Workaround for testing:**
Create events via API endpoint:
```python
# test_create_event.py
import requests

response = requests.post("http://localhost:8000/api/events", json={
    "camera_id": "test",
    "description": "Test event",
    # ...
})
```

**Note:** Full integration (main.py â†’ WebSocket) requires shared memory or IPC, which is out of scope for Story 5.3.

---

### Issue 3: "Memory leak - connections growing"

**Symptom:**
```bash
# Memory usage grows over time
# ps aux | grep web_server shows increasing memory
```

**Diagnosis:**
```python
# Add to api/routes/stream.py endpoint
logger.info(f"Active connections: {ws_manager.get_connection_count()}")
```

**Cause:** Dead connections not being cleaned up

**Solution:**
Ensure `disconnect()` is called in `finally` block:
```python
@router.websocket("/ws/events")
async def websocket_events(websocket: WebSocket):
    connection_id = None
    try:
        await websocket.accept()
        connection_id = ws_manager.connect(websocket)
        # ...
    finally:
        if connection_id:
            ws_manager.disconnect(connection_id)  # Always cleanup
```

---

### Issue 4: "Ping/pong not working"

**Symptom:**
- No ping messages received by client
- Heartbeat task not running

**Diagnosis:**
```bash
# Check logs for heartbeat startup
grep "heartbeat" logs/web_server.log
```

**Cause:** Heartbeat task not started in app startup

**Solution:**
Verify `app.on_event("startup")` includes heartbeat:
```python
@app.on_event("startup")
async def startup_event():
    ws_manager = get_websocket_manager()
    asyncio.create_task(ws_manager.start_heartbeat(interval=30))
    logger.info("Heartbeat task started")
```

---

### Issue 5: "TypeError: object dict can't be used in 'await' expression"

**Symptom:**
```python
TypeError: object dict can't be used in 'await' expression
```

**Cause:** Trying to await a non-async function

**Solution:**
EventManager is sync, use `asyncio.create_task()`:
```python
# BAD
await self.websocket_manager.broadcast_event(event_dict)

# GOOD
asyncio.create_task(
    self.websocket_manager.broadcast_event(event_dict)
)
```

---

## ðŸ“Š Success Metrics

| Metric | Target | How to Measure |
|--------|--------|----------------|
| Broadcast latency | <100ms | Time from event creation to client receipt |
| Memory per 100 clients | <10MB | Monitor process memory: `ps aux \| grep web_server` |
| CPU overhead | <2% | Monitor CPU: `top -pid <web_server_pid>` |
| Connection success rate | >99% | Count successful vs failed connections |
| Simultaneous connections | 100 | Load test with 100 clients |
| Ping interval | 30s | Measure time between pings |
| Unit test coverage | >80% | `pytest --cov=api/websocket` |

---

## ðŸŽ“ Learning Resources

**WebSocket Protocol:**
- MDN WebSocket API: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
- WebSocket RFC: https://tools.ietf.org/html/rfc6455

**FastAPI WebSocket:**
- FastAPI WebSocket docs: https://fastapi.tiangolo.com/advanced/websockets/
- Starlette WebSocket: https://www.starlette.io/websockets/

**Python Async:**
- asyncio docs: https://docs.python.org/3/library/asyncio.html
- async/await tutorial: https://realpython.com/async-io-python/

**Testing WebSocket:**
- websockets library: https://websockets.readthedocs.io/
- Testing async code: https://docs.pytest.org/en/stable/how-to/async.html

---

## â­ï¸ Next Steps After Story 5.3

Once this story is complete:

1. **Story 5.4:** Dashboard HTML/CSS Framework
   - Build responsive layout
   - Add placeholders for event feed
   - Style components

2. **Story 5.5:** Event Feed Component
   - Connect to WebSocket endpoint
   - Display events in real-time
   - Implement reconnection logic

3. **Story 5.6:** System Health Display
   - Use /api/metrics endpoint
   - Show CPU, memory, inference times
   - Update in real-time

---

## ðŸ“ Definition of Done

Before marking this story complete, verify:

### Implementation
- [ ] All 12 acceptance criteria met
- [ ] WebSocket endpoint functional
- [ ] WebSocketManager class complete
- [ ] EventManager integration complete
- [ ] Heartbeat mechanism working
- [ ] Error handling comprehensive

### Testing
- [ ] Unit tests passing (>80% coverage)
- [ ] Integration tests passing
- [ ] Manual browser test successful
- [ ] Load test (100 clients) successful
- [ ] No memory leaks detected

### Quality
- [ ] Code reviewed and approved
- [ ] No linting errors
- [ ] Type hints added
- [ ] Async code follows best practices
- [ ] Thread safety verified

### Documentation
- [ ] README updated with WebSocket docs
- [ ] Message formats documented
- [ ] Client example code provided
- [ ] Troubleshooting guide added

### Integration
- [ ] No breaking changes to Stories 5.1/5.2
- [ ] REST API still functional
- [ ] Static files still served
- [ ] Health check still works

---

**Estimated Time Breakdown:**
- WebSocketManager: 45 min
- WebSocket endpoint: 30 min
- Heartbeat logic: 20 min
- EventManager integration: 45 min
- FastAPI app integration: 15 min
- Unit tests: 90 min
- Integration tests: 45 min
- Load testing: 30 min
- Documentation: 30 min
- Code review & fixes: 60 min
- **Total: 7-9 hours**

Good luck! ðŸš€
