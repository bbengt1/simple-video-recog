# Story 5.2: Event API Endpoints

**Status:** Ready for Development

## Story

**As a** frontend developer,
**I want** REST API endpoints for querying events with filtering and pagination,
**so that** the dashboard can display historical and live events efficiently.

## Business Value

This story delivers the core data access layer for the web dashboard, enabling:
- Historical event browsing with time-range filtering
- Efficient pagination for large event datasets (10K+ events)
- Single event detail retrieval for modal views
- Annotated image serving for visual evidence
- System metrics access for health monitoring
- Foundation for search and filtering UI (Story 5.8)

## Acceptance Criteria

### 1. Event List Endpoint
- `GET /api/events` returns paginated list of events
- Query parameters supported:
  - `limit` (default: 100, max: 1000) - number of events to return
  - `offset` (default: 0) - pagination offset
  - `start` (optional) - ISO 8601 datetime for time range start
  - `end` (optional) - ISO 8601 datetime for time range end
  - `camera_id` (optional) - filter by camera identifier
- Response includes: events array, total count, limit, offset
- Events ordered by timestamp DESC (newest first)
- Response time <500ms for 100 events (NFR31)

### 2. Single Event Endpoint
- `GET /api/events/{event_id}` returns single event details
- Returns 404 if event not found
- Includes all event fields: detected objects, LLM description, image path
- Response time <100ms (database indexed lookup)

### 3. Event Image Endpoint
- `GET /api/events/{event_id}/image` serves annotated image
- Returns image with proper MIME type (image/jpeg)
- Returns 404 if image file not found
- Supports HTTP caching headers (7-day cache)
- Response time <200ms for typical image sizes (100-500KB)

### 4. System Metrics Endpoint
- `GET /api/metrics` returns current system metrics
- Response includes: frames processed, events created, inference times, CPU, memory
- Data sourced from MetricsCollector singleton
- Response time <100ms

### 5. Configuration Endpoint
- `GET /api/config` returns sanitized system configuration
- Excludes sensitive fields: RTSP URL, passwords
- Includes: camera_id, motion_threshold, blacklist_objects, model paths
- Response time <50ms

### 6. Pydantic Models
- API request/response models defined in `api/models.py`
- Models include: EventListResponse, EventResponse, MetricsResponse, ConfigResponse
- Full JSON schema validation
- Auto-generated OpenAPI documentation includes all models

### 7. Database Queries Optimized
- Uses indexes from migration 003 (idx_events_timestamp, idx_events_camera)
- Time-range queries use indexed timestamp column
- Camera filtering uses indexed camera_id column
- Query execution time <100ms for 10K events in database

### 8. Error Handling
- 400 Bad Request for invalid query parameters (negative offset, invalid datetime)
- 404 Not Found for missing event_id or image
- 500 Internal Server Error for database errors (with error logged)
- Error responses include: error code, message, timestamp, request_id

### 9. Response Validation
- All responses validated against Pydantic models
- Automatic serialization of datetime objects to ISO 8601
- JSON response format with proper Content-Type headers
- Consistent error response format across all endpoints

### 10. API Documentation
- OpenAPI/Swagger documentation auto-generated at `/docs`
- All endpoints documented with descriptions and examples
- Request/response schemas visible in Swagger UI
- Example responses provided for each endpoint

### 11. Performance Testing
- Load test with 1000 concurrent requests to `/api/events`
- API responds within SLA (500ms) under load
- No database connection exhaustion
- Memory usage remains stable (<200MB)

### 12. Integration with Story 5.1
- Uses FastAPI application from Story 5.1
- Uses read-only database connection from `api/dependencies.py`
- Routes added to existing application via router inclusion
- No breaking changes to existing health check endpoint

## Technical Specifications

### API Endpoint Definitions

#### 1. GET /api/events (Event List)

**Request:**
```http
GET /api/events?limit=100&offset=0&start=2025-11-01T00:00:00Z&end=2025-11-10T23:59:59Z&camera_id=front_door
```

**Response (200 OK):**
```json
{
  "events": [
    {
      "event_id": "evt_1699459335_a7b3c",
      "timestamp": "2025-11-08T14:32:15Z",
      "camera_id": "front_door",
      "motion_confidence": 0.87,
      "detected_objects": [
        {
          "label": "person",
          "confidence": 0.92,
          "bbox": {"x": 120, "y": 50, "width": 180, "height": 320}
        }
      ],
      "llm_description": "Person in blue shirt carrying brown package approaching front door",
      "image_path": "/images/2025-11-08/evt_1699459335_a7b3c.jpg",
      "created_at": "2025-11-08T14:32:16Z"
    }
  ],
  "total": 1523,
  "limit": 100,
  "offset": 0
}
```

**Query Parameter Validation:**
- `limit`: 1 ≤ limit ≤ 1000
- `offset`: offset ≥ 0
- `start`, `end`: Valid ISO 8601 datetime
- `camera_id`: Valid string (non-empty)

**Error Response (400 Bad Request):**
```json
{
  "error": {
    "code": "INVALID_QUERY_PARAM",
    "message": "Invalid limit parameter: must be between 1 and 1000",
    "timestamp": "2025-11-08T14:32:15Z",
    "request_id": "req_abc123"
  }
}
```

---

#### 2. GET /api/events/{event_id} (Single Event)

**Request:**
```http
GET /api/events/evt_1699459335_a7b3c
```

**Response (200 OK):**
```json
{
  "event_id": "evt_1699459335_a7b3c",
  "timestamp": "2025-11-08T14:32:15Z",
  "camera_id": "front_door",
  "motion_confidence": 0.87,
  "detected_objects": [
    {
      "label": "person",
      "confidence": 0.92,
      "bbox": {"x": 120, "y": 50, "width": 180, "height": 320}
    }
  ],
  "llm_description": "Person in blue shirt carrying brown package approaching front door",
  "image_path": "/images/2025-11-08/evt_1699459335_a7b3c.jpg",
  "json_log_path": "data/events/2025-11-08/events.json",
  "created_at": "2025-11-08T14:32:16Z"
}
```

**Error Response (404 Not Found):**
```json
{
  "error": {
    "code": "EVENT_NOT_FOUND",
    "message": "Event with ID 'evt_invalid' not found",
    "timestamp": "2025-11-08T14:32:15Z",
    "request_id": "req_abc123"
  }
}
```

---

#### 3. GET /api/events/{event_id}/image (Event Image)

**Request:**
```http
GET /api/events/evt_1699459335_a7b3c/image
```

**Response (200 OK):**
```http
Content-Type: image/jpeg
Content-Length: 245678
Cache-Control: public, max-age=604800

[Binary image data]
```

**Error Response (404 Not Found):**
```json
{
  "error": {
    "code": "IMAGE_NOT_FOUND",
    "message": "Image for event 'evt_1699459335_a7b3c' not found",
    "timestamp": "2025-11-08T14:32:15Z",
    "request_id": "req_abc123"
  }
}
```

---

#### 4. GET /api/metrics (System Metrics)

**Request:**
```http
GET /api/metrics
```

**Response (200 OK):**
```json
{
  "timestamp": "2025-11-08T14:32:00Z",
  "frames_processed": 15234,
  "motion_detected": 1205,
  "motion_hit_rate": 0.079,
  "events_created": 342,
  "events_suppressed": 98,
  "coreml_inference_avg": 45.3,
  "coreml_inference_min": 32.1,
  "coreml_inference_max": 98.7,
  "coreml_inference_p95": 67.2,
  "llm_inference_avg": 1234.5,
  "llm_inference_min": 987.2,
  "llm_inference_max": 2456.8,
  "llm_inference_p95": 1876.4,
  "frame_processing_latency_avg": 1456.7,
  "cpu_usage_current": 42.3,
  "cpu_usage_avg": 38.7,
  "memory_usage_mb": 2048,
  "memory_usage_gb": 2.0,
  "memory_usage_percent": 12.5,
  "system_uptime_percent": 99.8,
  "version": "1.0.0"
}
```

---

#### 5. GET /api/config (System Configuration)

**Request:**
```http
GET /api/config
```

**Response (200 OK):**
```json
{
  "camera_id": "front_door",
  "motion_threshold": 0.5,
  "frame_sample_rate": 5,
  "blacklist_objects": ["bird", "cat"],
  "min_object_confidence": 0.5,
  "ollama_model": "llava:7b",
  "max_storage_gb": 4.0,
  "min_retention_days": 7,
  "log_level": "INFO",
  "metrics_interval": 60,
  "version": "1.0.0"
}
```

**Note:** RTSP URL and sensitive fields are excluded from response.

---

### Implementation Code

#### Pydantic Models

```python
# api/models.py
from pydantic import BaseModel, Field
from datetime import datetime
from typing import List, Optional

class BoundingBox(BaseModel):
    """Bounding box coordinates for detected objects."""
    x: int = Field(..., ge=0)
    y: int = Field(..., ge=0)
    width: int = Field(..., gt=0)
    height: int = Field(..., gt=0)

class DetectedObject(BaseModel):
    """Object detected by CoreML."""
    label: str
    confidence: float = Field(..., ge=0.0, le=1.0)
    bbox: BoundingBox

class Event(BaseModel):
    """Event response model."""
    event_id: str
    timestamp: datetime
    camera_id: str
    motion_confidence: Optional[float] = Field(None, ge=0.0, le=1.0)
    detected_objects: List[DetectedObject]
    llm_description: str
    image_path: str
    json_log_path: Optional[str] = None
    created_at: datetime

    class Config:
        json_schema_extra = {
            "example": {
                "event_id": "evt_1699459335_a7b3c",
                "timestamp": "2025-11-08T14:32:15Z",
                "camera_id": "front_door",
                "motion_confidence": 0.87,
                "detected_objects": [
                    {
                        "label": "person",
                        "confidence": 0.92,
                        "bbox": {"x": 120, "y": 50, "width": 180, "height": 320}
                    }
                ],
                "llm_description": "Person in blue shirt carrying package",
                "image_path": "/images/2025-11-08/evt_1699459335_a7b3c.jpg",
                "created_at": "2025-11-08T14:32:16Z"
            }
        }

class EventListResponse(BaseModel):
    """Event list response with pagination."""
    events: List[Event]
    total: int = Field(..., ge=0)
    limit: int = Field(..., ge=1, le=1000)
    offset: int = Field(..., ge=0)

class MetricsResponse(BaseModel):
    """System metrics response."""
    timestamp: datetime
    frames_processed: int
    motion_detected: int
    motion_hit_rate: float
    events_created: int
    events_suppressed: int
    coreml_inference_avg: float
    coreml_inference_min: float
    coreml_inference_max: float
    coreml_inference_p95: float
    llm_inference_avg: float
    llm_inference_min: float
    llm_inference_max: float
    llm_inference_p95: float
    frame_processing_latency_avg: float
    cpu_usage_current: float
    cpu_usage_avg: float
    memory_usage_mb: int
    memory_usage_gb: float
    memory_usage_percent: float
    system_uptime_percent: float
    version: str

class ConfigResponse(BaseModel):
    """Sanitized system configuration (excludes sensitive fields)."""
    camera_id: str
    motion_threshold: float
    frame_sample_rate: int
    blacklist_objects: List[str]
    min_object_confidence: float
    ollama_model: str
    max_storage_gb: float
    min_retention_days: int
    log_level: str
    metrics_interval: int
    version: str

class ErrorDetail(BaseModel):
    """Error response detail."""
    code: str
    message: str
    timestamp: datetime
    request_id: str

class ErrorResponse(BaseModel):
    """Error response wrapper."""
    error: ErrorDetail
```

---

#### Event Routes

```python
# api/routes/events.py
from fastapi import APIRouter, Depends, HTTPException, Query, Path
from fastapi.responses import FileResponse
from datetime import datetime
from pathlib import Path as FilePath
from typing import Optional
import logging
import uuid
import json

from api.models import Event, EventListResponse, DetectedObject, BoundingBox
from api.dependencies import get_db_connection

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/events", response_model=EventListResponse)
async def list_events(
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of events to return"),
    offset: int = Query(0, ge=0, description="Number of events to skip"),
    start: Optional[datetime] = Query(None, description="Start of time range (ISO 8601)"),
    end: Optional[datetime] = Query(None, description="End of time range (ISO 8601)"),
    camera_id: Optional[str] = Query(None, description="Filter by camera ID"),
    db_conn = Depends(get_db_connection)
):
    """
    List events with pagination and filtering.

    Query events from the database with optional time range and camera filtering.
    Results are ordered by timestamp DESC (newest first).
    """
    request_id = str(uuid.uuid4())[:8]

    try:
        cursor = db_conn.cursor()

        # Build query
        query = "SELECT * FROM events WHERE 1=1"
        params = []

        if start:
            query += " AND timestamp >= ?"
            params.append(start.isoformat())

        if end:
            query += " AND timestamp <= ?"
            params.append(end.isoformat())

        if camera_id:
            query += " AND camera_id = ?"
            params.append(camera_id)

        # Count total
        count_query = query.replace("SELECT *", "SELECT COUNT(*)")
        cursor.execute(count_query, params)
        total = cursor.fetchone()[0]

        # Get paginated results
        query += " ORDER BY timestamp DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])

        cursor.execute(query, params)
        rows = cursor.fetchall()

        # Convert rows to Event models
        events = []
        for row in rows:
            # Parse detected_objects JSON
            detected_objects = json.loads(row['detected_objects']) if row['detected_objects'] else []
            detected_objects = [
                DetectedObject(
                    label=obj['label'],
                    confidence=obj['confidence'],
                    bbox=BoundingBox(**obj['bbox'])
                )
                for obj in detected_objects
            ]

            event = Event(
                event_id=row['event_id'],
                timestamp=datetime.fromisoformat(row['timestamp']),
                camera_id=row['camera_id'],
                motion_confidence=row['motion_confidence'],
                detected_objects=detected_objects,
                llm_description=row['llm_description'],
                image_path=f"/images/{row['image_path'].split('/')[-2]}/{row['image_path'].split('/')[-1]}",
                created_at=datetime.fromisoformat(row['created_at'])
            )
            events.append(event)

        logger.info(f"[{request_id}] Listed {len(events)} events (total: {total}, limit: {limit}, offset: {offset})")

        return EventListResponse(
            events=events,
            total=total,
            limit=limit,
            offset=offset
        )

    except Exception as e:
        logger.error(f"[{request_id}] Error listing events: {e}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.get("/events/{event_id}", response_model=Event)
async def get_event(
    event_id: str = Path(..., description="Event identifier"),
    db_conn = Depends(get_db_connection)
):
    """
    Get single event by ID.

    Returns full event details including all detected objects and metadata.
    """
    request_id = str(uuid.uuid4())[:8]

    try:
        cursor = db_conn.cursor()
        cursor.execute("SELECT * FROM events WHERE event_id = ?", (event_id,))
        row = cursor.fetchone()

        if not row:
            logger.warning(f"[{request_id}] Event not found: {event_id}")
            raise HTTPException(
                status_code=404,
                detail={
                    "code": "EVENT_NOT_FOUND",
                    "message": f"Event with ID '{event_id}' not found",
                    "timestamp": datetime.now().isoformat(),
                    "request_id": request_id
                }
            )

        # Parse detected_objects JSON
        detected_objects = json.loads(row['detected_objects']) if row['detected_objects'] else []
        detected_objects = [
            DetectedObject(
                label=obj['label'],
                confidence=obj['confidence'],
                bbox=BoundingBox(**obj['bbox'])
            )
            for obj in detected_objects
        ]

        event = Event(
            event_id=row['event_id'],
            timestamp=datetime.fromisoformat(row['timestamp']),
            camera_id=row['camera_id'],
            motion_confidence=row['motion_confidence'],
            detected_objects=detected_objects,
            llm_description=row['llm_description'],
            image_path=f"/images/{row['image_path'].split('/')[-2]}/{row['image_path'].split('/')[-1]}",
            json_log_path=row['json_log_path'],
            created_at=datetime.fromisoformat(row['created_at'])
        )

        logger.info(f"[{request_id}] Retrieved event: {event_id}")
        return event

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[{request_id}] Error retrieving event {event_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@router.get("/events/{event_id}/image")
async def get_event_image(
    event_id: str = Path(..., description="Event identifier"),
    db_conn = Depends(get_db_connection)
):
    """
    Get annotated image for event.

    Returns JPEG image with bounding boxes drawn on detected objects.
    Includes HTTP caching headers for 7-day cache.
    """
    request_id = str(uuid.uuid4())[:8]

    try:
        # Get event to find image path
        cursor = db_conn.cursor()
        cursor.execute("SELECT image_path FROM events WHERE event_id = ?", (event_id,))
        row = cursor.fetchone()

        if not row:
            raise HTTPException(
                status_code=404,
                detail={
                    "code": "EVENT_NOT_FOUND",
                    "message": f"Event with ID '{event_id}' not found",
                    "timestamp": datetime.now().isoformat(),
                    "request_id": request_id
                }
            )

        image_path = FilePath(row['image_path'])

        if not image_path.exists():
            logger.warning(f"[{request_id}] Image not found for event {event_id}: {image_path}")
            raise HTTPException(
                status_code=404,
                detail={
                    "code": "IMAGE_NOT_FOUND",
                    "message": f"Image for event '{event_id}' not found",
                    "timestamp": datetime.now().isoformat(),
                    "request_id": request_id
                }
            )

        logger.info(f"[{request_id}] Serving image for event {event_id}: {image_path}")

        return FileResponse(
            image_path,
            media_type="image/jpeg",
            headers={
                "Cache-Control": "public, max-age=604800",  # 7 days
                "X-Request-ID": request_id
            }
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[{request_id}] Error serving image for event {event_id}: {e}")
        raise HTTPException(status_code=500, detail=f"File system error: {str(e)}")
```

---

#### Metrics Routes

```python
# api/routes/metrics.py
from fastapi import APIRouter
from datetime import datetime
import logging

from api.models import MetricsResponse
from core.metrics import get_metrics_collector

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/metrics", response_model=MetricsResponse)
async def get_metrics():
    """
    Get current system metrics.

    Returns latest performance metrics from the MetricsCollector singleton.
    Includes processing statistics, inference times, and resource usage.
    """
    try:
        collector = get_metrics_collector()
        snapshot = collector.collect()

        response = MetricsResponse(
            timestamp=snapshot.timestamp,
            frames_processed=snapshot.frames_processed,
            motion_detected=snapshot.motion_detected,
            motion_hit_rate=snapshot.motion_hit_rate,
            events_created=snapshot.events_created,
            events_suppressed=snapshot.events_suppressed,
            coreml_inference_avg=snapshot.coreml_inference_avg,
            coreml_inference_min=snapshot.coreml_inference_min,
            coreml_inference_max=snapshot.coreml_inference_max,
            coreml_inference_p95=snapshot.coreml_inference_p95,
            llm_inference_avg=snapshot.llm_inference_avg,
            llm_inference_min=snapshot.llm_inference_min,
            llm_inference_max=snapshot.llm_inference_max,
            llm_inference_p95=snapshot.llm_inference_p95,
            frame_processing_latency_avg=snapshot.frame_processing_latency_avg,
            cpu_usage_current=snapshot.cpu_usage_current,
            cpu_usage_avg=snapshot.cpu_usage_avg,
            memory_usage_mb=snapshot.memory_usage_mb,
            memory_usage_gb=snapshot.memory_usage_gb,
            memory_usage_percent=snapshot.memory_usage_percent,
            system_uptime_percent=snapshot.system_uptime_percent,
            version="1.0.0"
        )

        logger.info("Metrics retrieved successfully")
        return response

    except Exception as e:
        logger.error(f"Error retrieving metrics: {e}")
        # Return empty metrics rather than failing
        return MetricsResponse(
            timestamp=datetime.now(),
            frames_processed=0,
            motion_detected=0,
            motion_hit_rate=0.0,
            events_created=0,
            events_suppressed=0,
            coreml_inference_avg=0.0,
            coreml_inference_min=0.0,
            coreml_inference_max=0.0,
            coreml_inference_p95=0.0,
            llm_inference_avg=0.0,
            llm_inference_min=0.0,
            llm_inference_max=0.0,
            llm_inference_p95=0.0,
            frame_processing_latency_avg=0.0,
            cpu_usage_current=0.0,
            cpu_usage_avg=0.0,
            memory_usage_mb=0,
            memory_usage_gb=0.0,
            memory_usage_percent=0.0,
            system_uptime_percent=0.0,
            version="1.0.0"
        )


@router.get("/config", response_model=ConfigResponse)
async def get_config():
    """
    Get sanitized system configuration.

    Returns configuration excluding sensitive fields (RTSP URL, passwords).
    """
    from api.dependencies import get_config

    try:
        config = get_config()

        response = ConfigResponse(
            camera_id=config.camera_id,
            motion_threshold=config.motion_threshold,
            frame_sample_rate=config.frame_sample_rate,
            blacklist_objects=config.blacklist_objects,
            min_object_confidence=config.min_object_confidence,
            ollama_model=config.ollama_model,
            max_storage_gb=config.max_storage_gb,
            min_retention_days=config.min_retention_days,
            log_level=config.log_level,
            metrics_interval=config.metrics_interval,
            version="1.0.0"
        )

        logger.info("Configuration retrieved successfully")
        return response

    except Exception as e:
        logger.error(f"Error retrieving configuration: {e}")
        raise HTTPException(status_code=500, detail=f"Configuration error: {str(e)}")
```

---

#### Integration with Story 5.1

```python
# api/app.py (UPDATE)
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pathlib import Path
import logging

from core.config import load_config
from api.routes import health, events, metrics  # NEW: Add events, metrics

logger = logging.getLogger(__name__)

def create_app() -> FastAPI:
    """Create and configure FastAPI application."""

    # Load configuration
    config = load_config("config/config.yaml")

    # Create FastAPI app
    app = FastAPI(
        title="Local Video Recognition System API",
        version="1.0.0",
        description="REST API for event access and system monitoring",
        docs_url="/docs",
        redoc_url="/redoc"
    )

    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:8000", "http://127.0.0.1:8000"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Include routers
    app.include_router(health.router, prefix="/api", tags=["health"])
    app.include_router(events.router, prefix="/api", tags=["events"])  # NEW
    app.include_router(metrics.router, prefix="/api", tags=["metrics"])  # NEW

    # Mount static files
    web_dir = Path(__file__).parent.parent / "web"
    if web_dir.exists():
        app.mount("/css", StaticFiles(directory=web_dir / "css"), name="css")
        app.mount("/js", StaticFiles(directory=web_dir / "js"), name="js")

        # Serve index.html at root
        from fastapi.responses import FileResponse

        @app.get("/")
        async def read_root():
            return FileResponse(web_dir / "index.html")

    # Mount event images
    events_dir = Path("data/events")
    if events_dir.exists():
        app.mount("/images", StaticFiles(directory=events_dir), name="images")

    logger.info("FastAPI application created with event and metrics routes")
    return app

app = create_app()
```

---

#### Helper Function for MetricsCollector Access

```python
# core/metrics.py (ADD SINGLETON ACCESS)

# Module-level singleton
_metrics_collector_instance = None

def get_metrics_collector():
    """
    Get MetricsCollector singleton instance.

    Used by API to access current metrics without database queries.
    """
    global _metrics_collector_instance
    if _metrics_collector_instance is None:
        _metrics_collector_instance = MetricsCollector()
    return _metrics_collector_instance
```

## Dependencies

### Prerequisites
- Story 5.1 complete (FastAPI server setup)
- Database migration 003 applied (API indexes)
- MetricsCollector implemented in core/metrics.py
- Database contains events for testing

### Blocked By
- Story 5.1: FastAPI Server Setup (REQUIRED)

### Blocks
- Story 5.3: Real-Time Event Streaming (needs event models)
- Story 5.4: Dashboard HTML/CSS Framework (needs API endpoints)
- Story 5.5: Event Feed Component (needs /api/events)
- Story 5.6: System Health Display (needs /api/metrics)
- Story 5.7: Event Detail Modal (needs /api/events/{id})
- Story 5.8: Search and Filtering (needs query parameters)

## Implementation Guidance

### Step-by-Step Implementation

1. **Create Pydantic models** (45 minutes)
   - Define all request/response models in `api/models.py`
   - Add JSON schema examples
   - Test model validation

2. **Implement event routes** (90 minutes)
   - Create `api/routes/events.py`
   - Implement `list_events()` with pagination
   - Implement `get_event()` with error handling
   - Implement `get_event_image()` with caching
   - Test each endpoint manually

3. **Implement metrics routes** (30 minutes)
   - Create `api/routes/metrics.py`
   - Implement `get_metrics()`
   - Implement `get_config()`
   - Test endpoints

4. **Add MetricsCollector singleton access** (15 minutes)
   - Update `core/metrics.py` with `get_metrics_collector()`
   - Test singleton access

5. **Integrate routes into FastAPI app** (15 minutes)
   - Update `api/app.py`
   - Include event and metrics routers
   - Test OpenAPI docs

6. **Write unit tests** (120 minutes)
   - Test event list endpoint (pagination, filtering)
   - Test single event endpoint (success, 404)
   - Test image endpoint (success, 404, caching)
   - Test metrics endpoint
   - Test config endpoint
   - Test error handling

7. **Performance testing** (30 minutes)
   - Load test with 1000 concurrent requests
   - Verify response times <500ms
   - Monitor memory usage

8. **Documentation** (30 minutes)
   - Update README with API examples
   - Add troubleshooting section
   - Document query parameters

### Estimated Effort
- **Implementation:** 5-6 hours
- **Testing:** 2-3 hours
- **Documentation:** 1 hour
- **Total:** 8-10 hours (1.5 days)

## Testing Requirements

### Unit Tests

```python
# tests/api/test_events.py
import pytest
from fastapi.testclient import TestClient
from datetime import datetime

from api.app import create_app

@pytest.fixture
def client():
    app = create_app()
    return TestClient(app)

def test_list_events_success(client):
    """Test event list returns 200 with valid pagination."""
    response = client.get("/api/events?limit=10&offset=0")

    assert response.status_code == 200
    data = response.json()
    assert "events" in data
    assert "total" in data
    assert "limit" in data
    assert "offset" in data
    assert data["limit"] == 10
    assert data["offset"] == 0
    assert isinstance(data["events"], list)

def test_list_events_time_range(client):
    """Test event list with time range filtering."""
    response = client.get(
        "/api/events?start=2025-11-01T00:00:00Z&end=2025-11-10T23:59:59Z"
    )

    assert response.status_code == 200
    data = response.json()
    for event in data["events"]:
        timestamp = datetime.fromisoformat(event["timestamp"].replace("Z", "+00:00"))
        assert datetime(2025, 11, 1) <= timestamp <= datetime(2025, 11, 10, 23, 59, 59)

def test_list_events_pagination(client):
    """Test pagination works correctly."""
    # Get first page
    page1 = client.get("/api/events?limit=10&offset=0").json()
    # Get second page
    page2 = client.get("/api/events?limit=10&offset=10").json()

    # Should have different events
    if len(page1["events"]) > 0 and len(page2["events"]) > 0:
        assert page1["events"][0]["event_id"] != page2["events"][0]["event_id"]

def test_list_events_invalid_limit(client):
    """Test invalid limit parameter returns 422."""
    response = client.get("/api/events?limit=2000")  # Max is 1000
    assert response.status_code == 422

def test_get_event_success(client):
    """Test getting single event returns 200."""
    # First get an event ID
    events = client.get("/api/events?limit=1").json()
    if len(events["events"]) > 0:
        event_id = events["events"][0]["event_id"]

        response = client.get(f"/api/events/{event_id}")
        assert response.status_code == 200
        data = response.json()
        assert data["event_id"] == event_id
        assert "detected_objects" in data
        assert "llm_description" in data

def test_get_event_not_found(client):
    """Test getting non-existent event returns 404."""
    response = client.get("/api/events/invalid_event_id")
    assert response.status_code == 404
    data = response.json()
    assert "error" in data
    assert data["error"]["code"] == "EVENT_NOT_FOUND"

def test_get_event_image_success(client):
    """Test getting event image returns JPEG."""
    # Get an event with image
    events = client.get("/api/events?limit=1").json()
    if len(events["events"]) > 0:
        event_id = events["events"][0]["event_id"]

        response = client.get(f"/api/events/{event_id}/image")
        if response.status_code == 200:
            assert response.headers["content-type"] == "image/jpeg"
            assert "cache-control" in response.headers
            assert "604800" in response.headers["cache-control"]  # 7 days

def test_list_events_response_time(client):
    """Test event list responds in <500ms."""
    import time
    start = time.time()
    response = client.get("/api/events?limit=100")
    duration = (time.time() - start) * 1000  # ms

    assert response.status_code == 200
    assert duration < 500, f"Event list took {duration}ms (target: <500ms)"

def test_get_metrics_success(client):
    """Test metrics endpoint returns 200."""
    response = client.get("/api/metrics")

    assert response.status_code == 200
    data = response.json()
    assert "timestamp" in data
    assert "frames_processed" in data
    assert "events_created" in data
    assert "coreml_inference_avg" in data

def test_get_config_success(client):
    """Test config endpoint returns 200."""
    response = client.get("/api/config")

    assert response.status_code == 200
    data = response.json()
    assert "camera_id" in data
    assert "motion_threshold" in data
    # Should NOT include sensitive fields
    assert "camera_rtsp_url" not in data
```

### Performance Tests

```python
# tests/performance/test_api_load.py
import pytest
import concurrent.futures
from fastapi.testclient import TestClient

from api.app import create_app

@pytest.fixture
def client():
    app = create_app()
    return TestClient(app)

def test_concurrent_requests(client):
    """Test API handles 1000 concurrent requests."""

    def make_request(i):
        response = client.get("/api/events?limit=100")
        return response.status_code, response.elapsed.total_seconds()

    with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
        futures = [executor.submit(make_request, i) for i in range(1000)]
        results = [f.result() for f in concurrent.futures.as_completed(futures)]

    # All requests should succeed
    assert all(status == 200 for status, _ in results)

    # 95th percentile response time should be <500ms
    response_times = sorted([duration for _, duration in results])
    p95_time = response_times[int(len(response_times) * 0.95)]
    assert p95_time < 0.5, f"P95 response time: {p95_time}s (target: <0.5s)"
```

### Manual Testing Checklist

- [ ] Event list endpoint returns paginated results
- [ ] Pagination works (offset/limit)
- [ ] Time range filtering works
- [ ] Camera ID filtering works
- [ ] Single event endpoint returns full details
- [ ] Event not found returns 404
- [ ] Event image endpoint serves JPEG
- [ ] Image not found returns 404
- [ ] Cache headers present on images
- [ ] Metrics endpoint returns current metrics
- [ ] Config endpoint excludes sensitive fields
- [ ] OpenAPI docs show all endpoints
- [ ] Response times meet targets (<500ms)
- [ ] Concurrent requests handled correctly

## Definition of Done

- [ ] All 12 acceptance criteria met
- [ ] Pydantic models defined with validation
- [ ] All 5 API endpoints implemented and tested
- [ ] Unit tests written and passing (>80% coverage)
- [ ] Performance tests passing (<500ms response time)
- [ ] Manual testing checklist complete
- [ ] OpenAPI documentation complete
- [ ] Integration with Story 5.1 successful
- [ ] No breaking changes to existing endpoints
- [ ] Code reviewed and approved
- [ ] Merged to main branch

## Success Metrics

- Event list response time: <500ms for 100 events (NFR31)
- Single event response time: <100ms
- Image response time: <200ms
- Metrics response time: <100ms
- Unit test coverage: >80% for api/routes/
- P95 response time under load: <500ms

## Notes

### Critical Integration Point

**MetricsCollector Access:**
The API needs access to the MetricsCollector singleton that's used by main.py. Add a module-level accessor function:

```python
# core/metrics.py
_metrics_collector_instance = None

def get_metrics_collector():
    global _metrics_collector_instance
    if _metrics_collector_instance is None:
        _metrics_collector_instance = MetricsCollector()
    return _metrics_collector_instance
```

### Security Considerations
- Configuration endpoint excludes sensitive fields (RTSP URL with credentials)
- All endpoints use read-only database connection
- No authentication required (localhost-only per NFR32)

### Future Enhancements (Out of Scope for 5.2)
- Search by LLM description text (Story 5.8)
- Object type filtering (Story 5.8)
- Confidence threshold filtering (Story 5.8)
- Export to CSV/JSON (Epic 6+)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-10 | 1.0 | Initial story creation | Winston (Architect) |

