# Story 4.6: Disk Full Detection and Graceful Shutdown

**Status:** Approved âœ…

**Story:**
**As a** system administrator,
**I want** the system to detect when disk space is full and shut down gracefully,
**so that** I don't lose data or corrupt the system when storage limits are exceeded.

**Acceptance Criteria:**

1. System monitors disk usage continuously during operation
2. When storage limit is exceeded, system logs clear error message and initiates graceful shutdown
3. No data corruption occurs during disk-full shutdown (events are saved, logs are flushed)
4. System exits with appropriate error code (different from success/normal shutdown)
5. Storage monitoring integrates with existing signal handling and shutdown sequence
6. Storage checks happen at configurable intervals without impacting performance

**Tasks / Subtasks:**

- [ ] Task 1: Integrate StorageMonitor into main application
  - [ ] Import StorageMonitor in main.py
  - [ ] Initialize StorageMonitor during startup after config loading
  - [ ] Pass StorageMonitor to components that need it (log rotator, etc.)
  - [ ] Add storage monitoring to session summary logging

- [ ] Task 2: Implement periodic storage checking in processing loop
  - [ ] Add storage check interval configuration (default: every 60 seconds)
  - [ ] Integrate storage checks into main processing loop
  - [ ] Check storage limits without blocking frame processing
  - [ ] Log storage usage statistics periodically

- [ ] Task 3: Implement disk-full shutdown trigger
  - [ ] Check StorageMonitor.should_shutdown() result during storage checks
  - [ ] When disk full detected, log critical error message
  - [ ] Trigger graceful shutdown sequence (same as SIGINT/SIGTERM)
  - [ ] Ensure shutdown completes within timeout (10 seconds)

- [ ] Task 4: Update exit codes for different shutdown scenarios
  - [ ] Define exit code constants (SUCCESS=0, ERROR=1, STORAGE_FULL=3)
  - [ ] Update main.py to use appropriate exit codes
  - [ ] Document exit codes in README.md
  - [ ] Update error handling to distinguish shutdown types

- [ ] Task 5: Add comprehensive error messaging
  - [ ] Clear error message when disk full detected: "Storage limit exceeded: X.XGB used, limit is Y.YGB"
  - [ ] Include cleanup instructions in error message
  - [ ] Log detailed storage statistics before shutdown
  - [ ] Ensure error message appears in both console and logs

- [ ] Task 6: Update health checks to include storage validation
  - [ ] Add storage availability check to startup health checks
  - [ ] Fail startup if storage is already over limit
  - [ ] Provide clear error message during startup validation
  - [ ] Test storage validation with mock full disk scenarios

- [ ] Task 7: Create unit tests for disk-full scenarios
  - [ ] Test StorageMonitor integration in main application
  - [ ] Test periodic storage checking without performance impact
  - [ ] Test disk-full detection triggers correct shutdown
  - [ ] Test appropriate exit codes for storage-full shutdown

- [ ] Task 8: Create integration tests for storage monitoring
  - [ ] Test full system behavior when storage limit exceeded
  - [ ] Test storage monitoring during normal operation
  - [ ] Test graceful shutdown preserves data integrity
  - [ ] Test system recovers after storage cleanup

**Dev Notes:**

**Previous Story Insights:**
- Story 4.5 completed signal handling with graceful shutdown sequence
- StorageMonitor class exists but not integrated into main application
- Main processing loop established with periodic operations (metrics logging)
- Health check system established for startup validation

**Technical Specifications:**
- Storage limits defined in config: `max_storage_gb` (default: 4.0GB)
- Storage monitoring should check every 60 seconds (configurable)
- Shutdown sequence: log error â†’ flush logs â†’ save events â†’ close connections â†’ exit
- Exit codes: SUCCESS=0, ERROR=1, CONFIG_INVALID=2, STORAGE_FULL=3
- Storage calculation includes: database files, event images, log files

**Data Models:**
- StorageStats dataclass with: total_bytes, limit_bytes, percentage_used, is_over_limit
- StorageMonitor.should_shutdown() returns boolean for shutdown trigger
- Integration with existing signal handling (shutdown_event, shutdown sequence)

**API Specifications:**
- StorageMonitor.get_storage_stats() returns StorageStats
- StorageMonitor.should_shutdown() returns bool
- Main loop integration: check every N iterations or time-based

**Testing Strategy:**
- Unit tests: StorageMonitor integration and shutdown triggering
- Integration tests: full system behavior with storage limits
- Edge cases: storage exactly at limit, rapid storage growth
- Performance: ensure storage checks don't impact frame processing

**Dependencies:**
- StorageMonitor class (core/storage_monitor.py) - already implemented
- Signal handling system (core/signals.py) - completed in story 4.5
- Health check system (core/health_check.py) - established in story 4.2

**Risk Assessment:**
- **Medium:** Storage monitoring could impact performance if not implemented efficiently
- **Low:** StorageMonitor class already exists and tested
- **Low:** Shutdown sequence established in previous story

**Definition of Done:**
- [ ] Storage monitoring integrated into main application
- [ ] Disk full detection triggers graceful shutdown
- [ ] Appropriate exit codes and error messages
- [ ] Startup validation includes storage checks
- [ ] All unit and integration tests pass
- [ ] Performance impact verified to be minimal
- [ ] Documentation updated in README.md

---

## PO Approval Summary âœ…

**Approved:** November 10, 2025
**Product Owner:** PO Agent
**Priority:** High (Critical for MVP completion)
**Business Value:** Production safety and operational reliability

### Approval Rationale
- **Essential for Production:** Addresses FR29 disk full detection requirement
- **High Business Impact:** Prevents data loss and system corruption in production
- **Low Technical Risk:** Builds on existing StorageMonitor infrastructure
- **MVP Completeness:** Final piece needed for production-ready system
- **User Trust:** Demonstrates professional error handling and safety

### Success Metrics
- **Reliability:** Zero data corruption during storage emergencies
- **User Experience:** Clear error messages guide administrators
- **Operational Safety:** Enables 24/7 deployment confidence
- **System Integrity:** Graceful degradation under resource constraints

### Next Steps
1. Assign to Dev agent for implementation
2. Complete Epic 4 production readiness
3. Enable Phase 2 (Web Dashboard) development
4. Prepare for MVP demonstration and validation

**Story approved and ready for development!** ðŸš€