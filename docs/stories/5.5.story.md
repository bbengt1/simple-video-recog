# Story 5.5: Event Feed Component

**Epic:** Epic 5 - Web Dashboard & Real-Time Monitoring
**Story ID:** 5.5
**Title:** Event Feed Component
**Estimated Effort:** 10-12 hours (1.5 days)
**Priority:** High
**Dependencies:** Stories 5.1, 5.2, 5.3, 5.4

---

## Story Description

**As a** system operator
**I want** to view a real-time feed of motion detection events in the dashboard
**So that** I can monitor camera activity as it happens and review historical events

### Context

Story 5.5 builds on the foundation established in Stories 5.1-5.4:
- **Story 5.1:** FastAPI server running on localhost:8000
- **Story 5.2:** REST API endpoints for events, images, metrics
- **Story 5.3:** WebSocket endpoint for real-time event streaming
- **Story 5.4:** Dashboard HTML/CSS structure with event feed container

This story implements the JavaScript client that:
1. Connects to the WebSocket endpoint for real-time updates
2. Fetches historical events from the REST API
3. Renders event cards in the main content area
4. Handles reconnection, loading states, and errors

---

## Business Value

**User Impact:**
- Operators see motion detection events in real-time (<1s latency)
- Historical events are accessible for review and analysis
- System status is visible (connected/disconnected/reconnecting)

**Technical Value:**
- Demonstrates WebSocket integration (NFR32: <1s latency)
- Validates API endpoints from Story 5.2
- Provides foundation for filtering/search (Story 5.8)

**Success Metrics:**
- Event display latency: <1s from detection to dashboard
- Page load time: <3s to display first 100 events (NFR31)
- Reconnection time: <5s after network interruption
- Zero memory leaks (stable over 24-hour monitoring session)

---

## Acceptance Criteria

### AC1: WebSocket Connection Established
**Given** the dashboard is loaded
**When** the page finishes loading
**Then** the system should:
- Connect to `ws://localhost:8000/ws/events`
- Display "Connected" status in the header
- Log connection success to browser console

**Verification:**
```bash
# Start web server
python web_server.py

# Open http://localhost:8000 in browser
# Open browser console (F12)
# Should see: "WebSocket connected" message
# Header status should show green dot + "Connected"
```

---

### AC2: Historical Events Loaded on Startup
**Given** the WebSocket connection is established
**When** the dashboard finishes loading
**Then** the system should:
- Fetch the last 100 events from `GET /api/events?limit=100`
- Render event cards in chronological order (newest first)
- Display loading spinner while fetching
- Remove spinner after events are rendered

**Verification:**
```bash
# Ensure database has events
sqlite3 surveillance.db "SELECT COUNT(*) FROM events;"
# Should return > 0

# Open dashboard
# Should see event cards appear within 3 seconds
# Cards should be sorted by timestamp (newest first)
```

---

### AC3: Real-Time Events Displayed
**Given** the dashboard is connected to WebSocket
**When** a new motion detection event occurs
**Then** the system should:
- Receive WebSocket message within 1 second
- Render new event card at the top of the feed
- Animate the new card (fade-in or slide-in)
- Update the event count in the header

**Verification:**
```bash
# Terminal 1: Start main application
python main.py

# Terminal 2: Start web server
python web_server.py

# Terminal 3: Trigger motion detection
# (Move in front of camera)

# Browser: Watch dashboard
# New event should appear within 1 second
```

---

### AC4: Event Card Rendering Complete
**Given** an event is received (REST or WebSocket)
**When** the event card is rendered
**Then** the card should display:
- Thumbnail image (300x200 or actual size)
- Camera ID (e.g., "Camera 1")
- Timestamp (formatted: "2025-11-10 14:30:45")
- Detected objects count (e.g., "3 objects detected")
- Object list (e.g., "person (95%), car (87%), dog (72%)")

**Verification:**
```javascript
// Browser console
document.querySelectorAll('.event-card').forEach(card => {
  console.log({
    hasImage: card.querySelector('img') !== null,
    hasCamera: card.querySelector('.camera-id') !== null,
    hasTimestamp: card.querySelector('.timestamp') !== null,
    hasObjects: card.querySelector('.detected-objects') !== null
  });
});
// All properties should be true
```

---

### AC5: Image Loading with Fallback
**Given** an event card is rendered
**When** the thumbnail image is loading
**Then** the system should:
- Display a placeholder image or gray box while loading
- Load image from `/api/images/{event_id}`
- Handle 404 errors with fallback placeholder
- Display image with proper aspect ratio (no distortion)

**Verification:**
```bash
# Test with missing image
sqlite3 surveillance.db "UPDATE events SET image_path = '/nonexistent.jpg' WHERE id = 1;"

# Reload dashboard
# Event card should show placeholder instead of broken image
```

---

### AC6: Reconnection Logic Implemented
**Given** the WebSocket connection is lost
**When** the connection drops
**Then** the system should:
- Display "Reconnecting..." status in the header (orange dot)
- Attempt reconnection with exponential backoff (1s, 2s, 4s, 8s, max 30s)
- Log reconnection attempts to browser console
- Fetch missed events after successful reconnection

**Verification:**
```bash
# Terminal 1: Start web server
python web_server.py

# Browser: Open dashboard, see "Connected" status

# Terminal 1: Stop web server (Ctrl+C)
# Browser: Should show "Reconnecting..." status

# Terminal 1: Restart web server
python web_server.py

# Browser: Should reconnect within 30 seconds
# Should show "Connected" status again
```

---

### AC7: Infinite Scroll Implemented
**Given** the initial 100 events are displayed
**When** the user scrolls to the bottom of the event feed
**Then** the system should:
- Detect scroll position (within 200px of bottom)
- Fetch next 50 events from `GET /api/events?limit=50&offset={current_count}`
- Append new events to the bottom of the feed
- Display loading indicator at the bottom while fetching

**Verification:**
```bash
# Ensure database has 150+ events
sqlite3 surveillance.db "SELECT COUNT(*) FROM events;"

# Open dashboard
# Scroll to bottom of event feed
# Should see loading spinner
# Should see 50 more events appear
```

---

### AC8: Empty State Handled
**Given** the database has zero events
**When** the dashboard loads
**Then** the system should:
- Display empty state message: "No events yet. Waiting for motion detection..."
- Show animated waiting icon (pulsing or spinning)
- Hide the empty state when the first event arrives

**Verification:**
```bash
# Clear database
sqlite3 surveillance.db "DELETE FROM events;"

# Open dashboard
# Should see empty state message
# Should NOT see error messages

# Trigger motion detection
# Empty state should disappear
# Event card should appear
```

---

### AC9: Error Handling Implemented
**Given** the API request fails
**When** fetching events returns an error (500, 404, network error)
**Then** the system should:
- Display user-friendly error message in the feed area
- Log detailed error to browser console
- Provide "Retry" button to attempt refetch
- Not break the UI or prevent WebSocket updates

**Verification:**
```bash
# Stop web server
# Open dashboard
# Should see: "Failed to load events. [Retry]" button

# Click "Retry" button
# Should attempt to refetch events
```

---

### AC10: State Management Pattern Implemented
**Given** multiple components need event data (feed, header, metrics)
**When** events are received or state changes
**Then** the system should:
- Use Observer Pattern (~50 LOC state management)
- Centralize state in EventStore singleton
- Notify subscribers when state changes (new event, connection status)
- Prevent direct DOM manipulation outside components

**Verification:**
```javascript
// Browser console
console.log(window.eventStore);
// Should see: { events: [...], connectionStatus: 'connected', subscribers: [...] }

// Subscribe to state changes
window.eventStore.subscribe((state) => {
  console.log('State updated:', state);
});

// Trigger event
// Should see console log with updated state
```

---

### AC11: Performance Optimized
**Given** 1000+ events are loaded over time
**When** the dashboard has been open for 24 hours
**Then** the system should:
- Limit in-memory events to 500 (oldest events removed)
- Use virtual scrolling or pagination (no rendering 1000+ DOM nodes)
- Maintain <100MB memory usage
- No visible memory leaks (stable memory over time)

**Verification:**
```javascript
// Browser DevTools > Performance > Memory
// Record memory over 1 hour
// Memory usage should stabilize after initial load
// No continuous growth (memory leak indicator)

// Check in-memory event count
console.log(window.eventStore.events.length);
// Should be ‚â§ 500 even if more events were received
```

---

### AC12: Accessibility Features
**Given** the event feed is displayed
**When** a screen reader user navigates the feed
**Then** the system should:
- Use semantic HTML (article for event cards)
- Provide ARIA labels for dynamic content updates
- Announce new events with aria-live="polite"
- Support keyboard navigation (Tab to navigate cards)

**Verification:**
```bash
# Enable screen reader (VoiceOver on macOS, NVDA on Windows)
# Navigate to dashboard
# Tab through event cards
# Should hear: "Event from Camera 1, timestamp, 3 objects detected"

# Trigger new event
# Should hear: "New event received" (aria-live announcement)
```

---

## Technical Design

### Architecture Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          Event Feed Component               ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   WebSocketClient                   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Connect to ws://localhost:8000   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Handle messages                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Reconnection logic               ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ             ‚îÇ onMessage(event)             ‚îÇ
‚îÇ             ‚ñº                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   EventStore (State Management)     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - events: Event[]                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - connectionStatus: string         ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - notify(subscribers)              ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ             ‚îÇ notify(state)                 ‚îÇ
‚îÇ             ‚ñº                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   EventFeedComponent                ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - renderEvents()                   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - createEventCard()                ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - handleScroll()                   ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### File Structure

```
web/
‚îú‚îÄ‚îÄ index.html                  # Main dashboard (from Story 5.4)
‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îú‚îÄ‚îÄ layout.css             # Layout system (from Story 5.4)
‚îÇ   ‚îî‚îÄ‚îÄ components.css         # Component styles (from Story 5.4)
‚îî‚îÄ‚îÄ js/
    ‚îú‚îÄ‚îÄ app.js                 # Application bootstrap
    ‚îú‚îÄ‚îÄ state/
    ‚îÇ   ‚îî‚îÄ‚îÄ EventStore.js      # State management (Observer Pattern)
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îú‚îÄ‚îÄ WebSocketClient.js # WebSocket connection
    ‚îÇ   ‚îî‚îÄ‚îÄ ApiClient.js       # REST API client
    ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îú‚îÄ‚îÄ EventFeed.js       # Event feed component
    ‚îÇ   ‚îî‚îÄ‚îÄ EventCard.js       # Event card component
    ‚îî‚îÄ‚îÄ utils/
        ‚îú‚îÄ‚îÄ formatters.js      # Date/time formatting
        ‚îî‚îÄ‚îÄ logger.js          # Console logging utility
```

---

## Implementation Details

### 1. WebSocketClient Service

```javascript
// web/js/services/WebSocketClient.js

class WebSocketClient {
  constructor(url, eventStore) {
    this.url = url;
    this.eventStore = eventStore;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectDelay = 30000; // 30 seconds
    this.reconnectTimer = null;
  }

  connect() {
    console.log(`[WebSocket] Connecting to ${this.url}`);

    try {
      this.ws = new WebSocket(this.url);

      this.ws.onopen = () => {
        console.log('[WebSocket] Connected');
        this.reconnectAttempts = 0;
        this.eventStore.updateConnectionStatus('connected');
      };

      this.ws.onmessage = (event) => {
        const message = JSON.parse(event.data);

        if (message.type === 'event') {
          console.log('[WebSocket] New event received:', message.data);
          this.eventStore.addEvent(message.data);
        } else if (message.type === 'ping') {
          this.ws.send(JSON.stringify({ type: 'pong' }));
        }
      };

      this.ws.onerror = (error) => {
        console.error('[WebSocket] Error:', error);
      };

      this.ws.onclose = () => {
        console.log('[WebSocket] Disconnected');
        this.eventStore.updateConnectionStatus('disconnected');
        this.scheduleReconnect();
      };
    } catch (error) {
      console.error('[WebSocket] Connection failed:', error);
      this.scheduleReconnect();
    }
  }

  scheduleReconnect() {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
    const delay = Math.min(
      1000 * Math.pow(2, this.reconnectAttempts),
      this.maxReconnectDelay
    );

    console.log(`[WebSocket] Reconnecting in ${delay / 1000}s (attempt ${this.reconnectAttempts + 1})`);
    this.eventStore.updateConnectionStatus('reconnecting');

    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

export default WebSocketClient;
```

---

### 2. ApiClient Service

```javascript
// web/js/services/ApiClient.js

class ApiClient {
  constructor(baseUrl = 'http://localhost:8000') {
    this.baseUrl = baseUrl;
  }

  async getEvents(params = {}) {
    const {
      limit = 100,
      offset = 0,
      start = null,
      end = null,
      camera_id = null
    } = params;

    // Build query string
    const query = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString()
    });

    if (start) query.append('start', start);
    if (end) query.append('end', end);
    if (camera_id) query.append('camera_id', camera_id);

    const url = `${this.baseUrl}/api/events?${query}`;

    console.log(`[API] GET ${url}`);

    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error('[API] Request failed:', error);
      throw error;
    }
  }

  getImageUrl(eventId) {
    return `${this.baseUrl}/api/images/${eventId}`;
  }

  async getMetrics() {
    const url = `${this.baseUrl}/api/metrics`;

    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('[API] Metrics request failed:', error);
      throw error;
    }
  }
}

export default ApiClient;
```

---

### 3. EventStore (State Management)

```javascript
// web/js/state/EventStore.js

class EventStore {
  constructor() {
    this.events = [];
    this.connectionStatus = 'disconnected';
    this.subscribers = [];
    this.maxEvents = 500; // Memory limit
  }

  // Observer Pattern: Subscribe to state changes
  subscribe(callback) {
    this.subscribers.push(callback);

    // Return unsubscribe function
    return () => {
      this.subscribers = this.subscribers.filter(sub => sub !== callback);
    };
  }

  // Notify all subscribers of state change
  notify() {
    const state = {
      events: this.events,
      connectionStatus: this.connectionStatus
    };

    this.subscribers.forEach(callback => callback(state));
  }

  // Add new event (from WebSocket or REST API)
  addEvent(event) {
    // Check if event already exists (prevent duplicates)
    const exists = this.events.some(e => e.event_id === event.event_id);
    if (exists) {
      console.log('[EventStore] Duplicate event ignored:', event.event_id);
      return;
    }

    // Add to beginning (newest first)
    this.events.unshift(event);

    // Enforce memory limit
    if (this.events.length > this.maxEvents) {
      this.events = this.events.slice(0, this.maxEvents);
      console.log(`[EventStore] Trimmed to ${this.maxEvents} events`);
    }

    this.notify();
  }

  // Add multiple events (from REST API)
  addEvents(events) {
    events.forEach(event => {
      // Check if event already exists
      const exists = this.events.some(e => e.event_id === event.event_id);
      if (!exists) {
        this.events.push(event);
      }
    });

    // Sort by timestamp (newest first)
    this.events.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // Enforce memory limit
    if (this.events.length > this.maxEvents) {
      this.events = this.events.slice(0, this.maxEvents);
    }

    this.notify();
  }

  // Update connection status
  updateConnectionStatus(status) {
    if (this.connectionStatus !== status) {
      this.connectionStatus = status;
      this.notify();
    }
  }

  // Get current state
  getState() {
    return {
      events: this.events,
      connectionStatus: this.connectionStatus
    };
  }
}

// Singleton instance
const eventStore = new EventStore();

export default eventStore;
```

---

### 4. EventFeed Component

```javascript
// web/js/components/EventFeed.js

import eventStore from '../state/EventStore.js';
import { createEventCard } from './EventCard.js';
import ApiClient from '../services/ApiClient.js';

class EventFeed {
  constructor(containerSelector) {
    this.container = document.querySelector(containerSelector);
    this.apiClient = new ApiClient();
    this.isLoading = false;
    this.hasMore = true;
    this.offset = 0;

    // Subscribe to state changes
    eventStore.subscribe((state) => {
      this.render(state.events);
    });

    // Setup infinite scroll
    this.setupInfiniteScroll();
  }

  async loadInitialEvents() {
    this.showLoading();

    try {
      const response = await this.apiClient.getEvents({ limit: 100 });
      eventStore.addEvents(response.events);
      this.offset = response.events.length;
      this.hasMore = response.total > response.events.length;
    } catch (error) {
      this.showError('Failed to load events. Please refresh the page.');
      console.error('[EventFeed] Load failed:', error);
    } finally {
      this.hideLoading();
    }
  }

  async loadMoreEvents() {
    if (this.isLoading || !this.hasMore) return;

    this.isLoading = true;
    this.showLoadingMore();

    try {
      const response = await this.apiClient.getEvents({
        limit: 50,
        offset: this.offset
      });

      eventStore.addEvents(response.events);
      this.offset += response.events.length;
      this.hasMore = this.offset < response.total;
    } catch (error) {
      console.error('[EventFeed] Load more failed:', error);
    } finally {
      this.isLoading = false;
      this.hideLoadingMore();
    }
  }

  setupInfiniteScroll() {
    this.container.addEventListener('scroll', () => {
      const scrollTop = this.container.scrollTop;
      const scrollHeight = this.container.scrollHeight;
      const clientHeight = this.container.clientHeight;

      // Trigger when within 200px of bottom
      if (scrollHeight - scrollTop - clientHeight < 200) {
        this.loadMoreEvents();
      }
    });
  }

  render(events) {
    if (events.length === 0) {
      this.showEmptyState();
      return;
    }

    // Clear container
    this.container.innerHTML = '';

    // Render event cards
    events.forEach(event => {
      const card = createEventCard(event);
      this.container.appendChild(card);
    });
  }

  showLoading() {
    this.container.innerHTML = `
      <div class="loading-state">
        <div class="spinner"></div>
        <p>Loading events...</p>
      </div>
    `;
  }

  hideLoading() {
    const loadingState = this.container.querySelector('.loading-state');
    if (loadingState) {
      loadingState.remove();
    }
  }

  showLoadingMore() {
    const existing = this.container.querySelector('.loading-more');
    if (existing) return;

    const loadingMore = document.createElement('div');
    loadingMore.className = 'loading-more';
    loadingMore.innerHTML = `
      <div class="spinner"></div>
      <p>Loading more events...</p>
    `;
    this.container.appendChild(loadingMore);
  }

  hideLoadingMore() {
    const loadingMore = this.container.querySelector('.loading-more');
    if (loadingMore) {
      loadingMore.remove();
    }
  }

  showEmptyState() {
    this.container.innerHTML = `
      <div class="empty-state">
        <div class="empty-icon">üìπ</div>
        <h3>No events yet</h3>
        <p>Waiting for motion detection...</p>
      </div>
    `;
  }

  showError(message) {
    this.container.innerHTML = `
      <div class="error-state">
        <div class="error-icon">‚ö†Ô∏è</div>
        <h3>Error</h3>
        <p>${message}</p>
        <button class="btn-retry" onclick="location.reload()">Retry</button>
      </div>
    `;
  }
}

export default EventFeed;
```

---

### 5. EventCard Component

```javascript
// web/js/components/EventCard.js

import ApiClient from '../services/ApiClient.js';
import { formatTimestamp, formatConfidence } from '../utils/formatters.js';

const apiClient = new ApiClient();

export function createEventCard(event) {
  const card = document.createElement('article');
  card.className = 'event-card';
  card.setAttribute('data-event-id', event.event_id);

  // Image
  const imageUrl = apiClient.getImageUrl(event.event_id);
  const img = document.createElement('img');
  img.src = imageUrl;
  img.alt = `Event from ${event.camera_id}`;
  img.loading = 'lazy';
  img.onerror = () => {
    img.src = '/static/placeholder.png'; // Fallback
  };

  // Card content
  const content = document.createElement('div');
  content.className = 'event-card-content';

  // Header
  const header = document.createElement('div');
  header.className = 'event-card-header';
  header.innerHTML = `
    <span class="camera-id">${event.camera_id}</span>
    <span class="timestamp">${formatTimestamp(event.timestamp)}</span>
  `;

  // Detected objects
  const objects = parseDetectedObjects(event.detected_objects);
  const objectsDiv = document.createElement('div');
  objectsDiv.className = 'detected-objects';

  if (objects.length > 0) {
    objectsDiv.innerHTML = `
      <p class="objects-count">${objects.length} object${objects.length > 1 ? 's' : ''} detected:</p>
      <ul class="objects-list">
        ${objects.map(obj => `
          <li>
            <span class="object-name">${obj.name}</span>
            <span class="object-confidence">${formatConfidence(obj.confidence)}</span>
          </li>
        `).join('')}
      </ul>
    `;
  } else {
    objectsDiv.innerHTML = '<p class="objects-count">No objects detected</p>';
  }

  // Assemble card
  content.appendChild(header);
  content.appendChild(objectsDiv);
  card.appendChild(img);
  card.appendChild(content);

  // Fade-in animation for new events
  card.style.animation = 'fadeIn 0.3s ease-in';

  return card;
}

function parseDetectedObjects(jsonString) {
  if (!jsonString) return [];

  try {
    const objects = JSON.parse(jsonString);

    // Sort by confidence (highest first)
    return objects.sort((a, b) => b.confidence - a.confidence);
  } catch (error) {
    console.error('[EventCard] Failed to parse detected_objects:', error);
    return [];
  }
}
```

---

### 6. Utility Functions

```javascript
// web/js/utils/formatters.js

export function formatTimestamp(timestamp) {
  const date = new Date(timestamp);

  // Format: "2025-11-10 14:30:45"
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');

  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

export function formatConfidence(confidence) {
  // confidence is 0-1, convert to percentage
  return `${Math.round(confidence * 100)}%`;
}

export function formatRelativeTime(timestamp) {
  const now = new Date();
  const date = new Date(timestamp);
  const diffMs = now - date;
  const diffSeconds = Math.floor(diffMs / 1000);

  if (diffSeconds < 60) return `${diffSeconds}s ago`;

  const diffMinutes = Math.floor(diffSeconds / 60);
  if (diffMinutes < 60) return `${diffMinutes}m ago`;

  const diffHours = Math.floor(diffMinutes / 60);
  if (diffHours < 24) return `${diffHours}h ago`;

  const diffDays = Math.floor(diffHours / 24);
  return `${diffDays}d ago`;
}
```

---

### 7. Application Bootstrap

```javascript
// web/js/app.js

import eventStore from './state/EventStore.js';
import WebSocketClient from './services/WebSocketClient.js';
import EventFeed from './components/EventFeed.js';

class App {
  constructor() {
    this.wsClient = null;
    this.eventFeed = null;
  }

  async init() {
    console.log('[App] Initializing dashboard...');

    // Initialize event feed component
    this.eventFeed = new EventFeed('.main-content');

    // Load initial events from REST API
    await this.eventFeed.loadInitialEvents();

    // Connect to WebSocket for real-time updates
    this.wsClient = new WebSocketClient('ws://localhost:8000/ws/events', eventStore);
    this.wsClient.connect();

    // Subscribe to connection status for header update
    eventStore.subscribe((state) => {
      this.updateConnectionStatus(state.connectionStatus);
    });

    console.log('[App] Dashboard ready');
  }

  updateConnectionStatus(status) {
    const statusElement = document.querySelector('.connection-status');
    if (!statusElement) return;

    const statusDot = statusElement.querySelector('.status-dot');
    const statusText = statusElement.querySelector('.status-text');

    if (status === 'connected') {
      statusDot.className = 'status-dot connected';
      statusText.textContent = 'Connected';
    } else if (status === 'reconnecting') {
      statusDot.className = 'status-dot reconnecting';
      statusText.textContent = 'Reconnecting...';
    } else {
      statusDot.className = 'status-dot disconnected';
      statusText.textContent = 'Disconnected';
    }
  }
}

// Initialize app when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    const app = new App();
    app.init();
  });
} else {
  const app = new App();
  app.init();
}

// Expose eventStore for debugging
window.eventStore = eventStore;
```

---

## CSS Additions

```css
/* web/css/components.css - Event Feed Additions */

/* Event Card */
.event-card {
  display: flex;
  gap: var(--spacing-md);
  background: var(--bg-secondary);
  border: 1px solid var(--bg-tertiary);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}

.event-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  cursor: pointer;
}

.event-card img {
  width: 300px;
  height: 200px;
  object-fit: cover;
  border-radius: var(--radius-sm);
  background: var(--bg-tertiary); /* Placeholder while loading */
}

.event-card-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
}

.event-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.camera-id {
  font-weight: 600;
  color: var(--accent-primary);
}

.timestamp {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}

.detected-objects {
  margin-top: var(--spacing-sm);
}

.objects-count {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
  margin-bottom: var(--spacing-xs);
}

.objects-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.objects-list li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-xs);
  background: var(--bg-tertiary);
  border-radius: var(--radius-sm);
}

.object-name {
  text-transform: capitalize;
}

.object-confidence {
  font-size: var(--font-size-sm);
  color: var(--accent-success);
  font-weight: 600;
}

/* Loading States */
.loading-state,
.loading-more {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xl);
  gap: var(--spacing-md);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--bg-tertiary);
  border-top-color: var(--accent-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Empty State */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xxl);
  text-align: center;
}

.empty-icon {
  font-size: 64px;
  margin-bottom: var(--spacing-md);
  opacity: 0.5;
}

.empty-state h3 {
  color: var(--text-primary);
  margin-bottom: var(--spacing-sm);
}

.empty-state p {
  color: var(--text-secondary);
}

/* Error State */
.error-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xxl);
  text-align: center;
}

.error-icon {
  font-size: 64px;
  margin-bottom: var(--spacing-md);
}

.error-state h3 {
  color: var(--accent-error);
  margin-bottom: var(--spacing-sm);
}

.btn-retry {
  margin-top: var(--spacing-md);
  padding: var(--spacing-sm) var(--spacing-lg);
  background: var(--accent-primary);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-size: var(--font-size-base);
  transition: background var(--transition-fast);
}

.btn-retry:hover {
  background: var(--accent-primary-dark);
}

/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Connection Status (Header) */
.connection-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  animation: pulse 2s ease-in-out infinite;
}

.status-dot.connected {
  background: var(--accent-success);
}

.status-dot.reconnecting {
  background: var(--accent-warning);
}

.status-dot.disconnected {
  background: var(--accent-error);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.status-text {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}
```

---

## Testing Strategy

### Unit Tests (Optional - JavaScript testing framework)

```javascript
// tests/eventStore.test.js

import eventStore from '../web/js/state/EventStore.js';

describe('EventStore', () => {
  test('addEvent should add event to beginning of array', () => {
    eventStore.events = [];

    const event1 = { event_id: '1', timestamp: '2025-11-10T10:00:00Z' };
    eventStore.addEvent(event1);

    expect(eventStore.events.length).toBe(1);
    expect(eventStore.events[0]).toEqual(event1);
  });

  test('addEvent should prevent duplicates', () => {
    eventStore.events = [];

    const event1 = { event_id: '1', timestamp: '2025-11-10T10:00:00Z' };
    eventStore.addEvent(event1);
    eventStore.addEvent(event1); // Duplicate

    expect(eventStore.events.length).toBe(1);
  });

  test('addEvents should sort by timestamp descending', () => {
    eventStore.events = [];

    const events = [
      { event_id: '1', timestamp: '2025-11-10T10:00:00Z' },
      { event_id: '2', timestamp: '2025-11-10T12:00:00Z' },
      { event_id: '3', timestamp: '2025-11-10T11:00:00Z' }
    ];

    eventStore.addEvents(events);

    expect(eventStore.events[0].event_id).toBe('2'); // Latest first
    expect(eventStore.events[2].event_id).toBe('1'); // Oldest last
  });

  test('should enforce memory limit', () => {
    eventStore.events = [];
    eventStore.maxEvents = 500;

    // Add 600 events
    for (let i = 0; i < 600; i++) {
      eventStore.addEvent({ event_id: `${i}`, timestamp: new Date().toISOString() });
    }

    expect(eventStore.events.length).toBe(500);
  });
});
```

### Manual Testing

```bash
# Test 1: Initial load
python web_server.py
# Open http://localhost:8000
# Verify: Events load within 3 seconds
# Verify: Status shows "Connected"

# Test 2: Real-time updates
# Terminal 1: python main.py
# Terminal 2: python web_server.py
# Trigger motion detection
# Verify: New event appears within 1 second

# Test 3: Reconnection
# Start web server
# Open dashboard
# Stop web server (Ctrl+C)
# Verify: Status shows "Reconnecting..."
# Restart web server
# Verify: Status shows "Connected" within 30 seconds

# Test 4: Infinite scroll
# Open dashboard with 150+ events
# Scroll to bottom
# Verify: 50 more events load

# Test 5: Empty state
sqlite3 surveillance.db "DELETE FROM events;"
# Open dashboard
# Verify: Empty state message displayed

# Test 6: Image fallback
sqlite3 surveillance.db "UPDATE events SET image_path = '/nonexistent.jpg' WHERE id = 1;"
# Open dashboard
# Verify: Placeholder image shown
```

---

## Non-Functional Requirements

| ID | Requirement | Implementation |
|----|-------------|----------------|
| **NFR31** | Dashboard loads in <3s | Critical CSS inlined, lazy loading |
| **NFR32** | Events appear within 1s | WebSocket real-time streaming |
| **NFR33** | Memory stable over 24h | 500 event limit, no memory leaks |
| **NFR34** | WCAG AA accessible | ARIA labels, keyboard navigation |

---

## Dependencies

**Blocked By:**
- Story 5.1: FastAPI Server Setup (web server running)
- Story 5.2: Event API Endpoints (REST API endpoints)
- Story 5.3: Real-Time Event Streaming (WebSocket endpoint)
- Story 5.4: Dashboard HTML/CSS Framework (HTML structure)

**Blocks:**
- Story 5.6: System Health Display (metrics panel)
- Story 5.7: Event Detail Modal (click event cards)
- Story 5.8: Search and Filtering (filter event feed)

**External Dependencies:**
- Modern browser with ES6+ support
- WebSocket support (all modern browsers)

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| WebSocket connection drops frequently | High | Exponential backoff reconnection (max 30s) |
| Memory leak from unlimited events | High | Enforce 500 event limit in EventStore |
| Image loading slows down feed | Medium | Lazy loading (loading="lazy") |
| API requests fail | Medium | Error handling with retry button |
| Duplicate events displayed | Low | Check event_id before adding to EventStore |

---

## Future Enhancements (Post-Story)

1. **Virtual Scrolling:** Render only visible event cards (improves performance for 1000+ events)
2. **Image Caching:** Cache images in IndexedDB (reduce bandwidth)
3. **Relative Timestamps:** "5 minutes ago" instead of absolute timestamps
4. **Event Filtering:** Filter events by camera, time range (Story 5.8)
5. **Event Detail Modal:** Click event card to see full details (Story 5.7)

---

## Definition of Done

- [ ] All 12 acceptance criteria verified and passing
- [ ] WebSocket connection established and reconnects on disconnect
- [ ] Historical events loaded from REST API on startup
- [ ] Real-time events displayed within 1 second
- [ ] Event cards render with image, timestamp, camera, objects
- [ ] Infinite scroll loads more events
- [ ] Empty state and error states displayed correctly
- [ ] Memory stable under 100MB over 24 hours
- [ ] Browser console shows no errors
- [ ] Manual testing completed (6 test cases)
- [ ] Code reviewed and approved
- [ ] Story documented in implementation guide

---

## Related Documentation

- **Architecture:** `docs/architecture/epic-5-architecture-diagrams.md`
- **Epic Document:** `docs/epic-5.web-dashboard.md`
- **Story 5.1:** FastAPI Server Setup
- **Story 5.2:** Event API Endpoints
- **Story 5.3:** Real-Time Event Streaming
- **Story 5.4:** Dashboard HTML/CSS Framework
- **ADR-005:** WebSocket vs SSE Decision

---

## Revision History

| Date | Version | Changes | Author |
|------|---------|---------|--------|
| 2025-11-10 | 1.0 | Initial story creation | Winston (Architect) |
