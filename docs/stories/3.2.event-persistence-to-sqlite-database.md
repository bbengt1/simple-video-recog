# Story 3.2: Event Persistence to SQLite Database

**Status:** Draft

**Story:**
**As a** developer,
**I want** to persist Event objects to the SQLite database,
**so that** events are permanently stored and queryable for historical analysis.

**Acceptance Criteria:**

1. DatabaseManager.insert_event(event: Event) method persists Event object to database
2. Event fields mapped to database columns: event_id → event_id, timestamp → timestamp, etc.
3. detected_objects list serialized to JSON TEXT before storage
4. INSERT statement uses parameterized queries to prevent SQL injection
5. Duplicate event_id handling: UNIQUE constraint prevents duplicate inserts, log WARNING if duplicate detected
6. insert_event() returns success boolean: True if inserted, False if duplicate or error
7. Database write errors (disk full, permission denied) logged and raised as DatabaseWriteError
8. Performance: Insert completes in <10ms (measured and logged if exceeds threshold)
9. Batch insert support: insert_events(events: list[Event]) for efficient bulk operations
10. Unit tests verify: single event insert, duplicate handling, batch insert, error scenarios
11. Integration test: Insert 1000 events via pipeline, query database, verify all present with correct data
12. Foreign key support prepared for Phase 2 multi-camera (camera_id references cameras table in future)

**Tasks / Subtasks:**

- [ ] Task 1: Implement insert_event method (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Extend DatabaseManager.insert_event() to persist Event objects
  - [ ] Map Event fields to database columns correctly
  - [ ] Implement JSON serialization for detected_objects field
  - [ ] Use parameterized INSERT queries to prevent SQL injection
  - [ ] Handle UNIQUE constraint violations for duplicate event_ids
  - [ ] Return boolean success indicator
- [ ] Task 2: Implement error handling and performance monitoring (AC: 7, 8)
  - [ ] Define DatabaseWriteError custom exception class
  - [ ] Add proper error handling for database write failures
  - [ ] Implement performance timing for insert operations
  - [ ] Log performance warnings if inserts exceed 10ms threshold
  - [ ] Add transaction rollback on write failures
- [ ] Task 3: Implement batch insert functionality (AC: 9)
  - [ ] Add insert_events() method for bulk operations
  - [ ] Optimize batch inserts for performance
  - [ ] Maintain transaction atomicity for batch operations
  - [ ] Return success/failure counts for batch operations
- [ ] Task 4: Create unit tests for persistence functionality (AC: 10)
  - [ ] Extend tests/unit/test_database.py with insert_event tests
  - [ ] Test single event insertion with all field mappings
  - [ ] Test duplicate event_id handling
  - [ ] Test batch insert functionality
  - [ ] Test error scenarios (database full, permission denied)
  - [ ] Mock SQLite operations for isolation
- [ ] Task 5: Create integration tests for database persistence (AC: 11)
  - [ ] Extend tests/integration/test_database_integration.py
  - [ ] Test inserting 1000 events with realistic data
  - [ ] Verify data integrity and queryability after bulk insert
  - [ ] Test performance characteristics of bulk operations
  - [ ] Validate JSON serialization/deserialization round-trip
- [ ] Task 6: Prepare for future multi-camera support (AC: 12)
  - [ ] Ensure camera_id field is properly indexed and constrained
  - [ ] Add comments indicating future foreign key relationships
  - [ ] Design schema to be extensible for multi-camera Phase 2

**Dev Notes:**

**Previous Story Insights:**
Story 3.1 implemented the DatabaseManager class with schema initialization, migration support, and basic database connection management. The database schema includes all required fields for event storage with proper indexing. DatabaseError exception class was added for error handling. Single connection pattern established for application lifetime. [Source: docs/stories/3.1.sqlite-database-setup-and-schema-implementation.md]

**Data Models:**
Event model includes all fields needed for database persistence: event_id (str), timestamp (datetime), camera_id (str), motion_confidence (Optional[float]), detected_objects (List[DetectedObject]), llm_description (str), image_path (str), json_log_path (str). DetectedObjects must be JSON serialized before database storage. [Source: docs/architecture/event.md]

**Database Schema:**
Events table schema with exact field mappings: event_id TEXT UNIQUE, timestamp DATETIME, camera_id TEXT, motion_confidence REAL, detected_objects TEXT (JSON), llm_description TEXT, image_path TEXT, json_log_path TEXT. UNIQUE constraint on event_id prevents duplicates. [Source: docs/architecture/events-table-sqlite.md]

**Backend Architecture:**
DatabaseManager class in core/database.py handles all database operations. Single connection reused throughout application lifetime. Transaction support required for atomic operations. Custom DatabaseError exceptions for proper error handling. [Source: docs/architecture/backend-error-handling.md]

**Technology Stack:**
SQLite 3.42+ for ACID compliance and JSON support. Single connection pattern (no pooling needed). Parameterized queries prevent SQL injection. Transactions required for atomicity. [Source: docs/architecture/technology-stack-table.md]

**File Locations:**
Database code in core/database.py. Unit tests in tests/unit/test_database.py. Integration tests in tests/integration/test_database_integration.py. New DatabaseWriteError exception in core/exceptions.py. [Source: docs/architecture/repository-structure.md]

**Technical Constraints:**
Use SQLite 3.42+ with ACID compliance. Single connection pattern for application lifetime. Parameterized queries mandatory to prevent SQL injection. Transaction support for atomic operations. Performance target: <10ms per insert operation. [Source: docs/architecture/technology-stack-table.md]

**Testing Requirements:**
Unit tests for database logic with mocked SQLite operations. Integration tests with real SQLite database. Test coverage ≥70% for database module. Use pytest framework with fixtures for test data. [Source: docs/architecture/testing-pyramid.md, docs/architecture/unit-test-best-practices.md]

**Code Organization Patterns:**
Python module structure: DatabaseManager class methods in core/database.py. Use type hints and Google-style docstrings. Follow PEP 8 with 100 char line length. [Source: docs/architecture/python-code-style.md, docs/architecture/code-organization-patterns.md]

**Testing:**
- Test file location: tests/unit/test_database.py for unit tests, tests/integration/test_database_integration.py for integration tests
- Test standards: pytest framework, ≥70% coverage, mock external dependencies
- Testing frameworks and patterns: pytest fixtures for common test data, parametrized tests for multiple scenarios
- Specific testing requirements: Test database insertion, duplicate handling, batch operations, error scenarios, performance timing

**Change Log:**

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-09 | 1.0 | Initial story creation for Epic 3 event persistence | Scrum Master |

**Dev Agent Record:**

**Agent Model Used:**
[To be filled by Dev Agent]

**Debug Log References:**
[To be filled by Dev Agent]

**Completion Notes List:**
[To be filled by Dev Agent]

**File List:**
[To be filled by Dev Agent]

**QA Results:**
[To be filled by QA Agent]

---

**Story Draft Validation Report**

| Category                             | Status | Issues |
| ------------------------------------ | ------ | ------ |
| 1. Goal & Context Clarity            | PASS   | Clear purpose, epic relationship, and business value established |
| 2. Technical Implementation Guidance | PASS   | Key files, technologies, APIs, and data models identified |
| 3. Reference Effectiveness           | PASS   | Specific sections referenced with context provided |
| 4. Self-Containment Assessment       | PASS   | Core requirements included, assumptions explicit, edge cases addressed |
| 5. Testing Guidance                  | PASS   | Unit/integration approach specified with key scenarios |

**Final Assessment: READY**

The story provides sufficient context for implementation. All acceptance criteria are clearly defined, technical requirements are well-specified, and the developer has enough information to proceed without excessive research. The story builds appropriately on Story 3.1 while being self-contained for the persistence functionality.