# Story 1.5: Basic Logging Framework and Console Output

## Status
Approved

## Story
**As a** developer,
**I want** structured logging with configurable verbosity levels,
**so that** I can debug issues during development and monitor the system in production.

## Acceptance Criteria

1. Python logging configured in core/logging_config.py with setup_logging(config) function
2. Logging level configurable via YAML: DEBUG, INFO, WARNING, ERROR
3. Console handler outputs to stdout with formatted messages: "[TIMESTAMP] [LEVEL] [MODULE] Message"
4. Timestamp format: ISO 8601 with timezone (2025-11-08T14:32:15-08:00)
5. Module name included in log output for easy debugging (e.g., [rtsp], [motion], [pipeline])
6. Structured logging metadata available for future JSON output (not yet implemented, but architecture supports it)
7. Key events logged at INFO level: RTSP connected, motion detected, frame processed, metrics summary
8. Errors logged at ERROR level with full exception stack traces
9. DEBUG level logs frame-by-frame processing details (frame number, motion confidence, sampling decision)
10. Logging performance overhead measured: <2% CPU impact at INFO level, <5% at DEBUG level (verified via profiling)
11. Unit tests verify correct log level filtering (DEBUG messages don't appear when level=INFO)
12. Manual test: Run system with different log levels, verify appropriate messages appear/disappear

## Tasks / Subtasks

- [x] **Task 1: Create logging configuration module structure** (AC: 1, 2)
  - [x] Create `core/logging_config.py` module file
  - [x] Define `setup_logging(config: SystemConfig) -> None` function
  - [x] Parse log_level from config (DEBUG, INFO, WARNING, ERROR)
  - [x] Configure Python logging with appropriate level
  - [x] Add proper type hints and Google-style function docstring

- [x] **Task 2: Implement console handler with custom formatting** (AC: 3, 4, 5)
  - [x] Create custom formatter class for console output
  - [x] Implement timestamp formatting: ISO 8601 with timezone
  - [x] Add module name extraction from logger name
  - [x] Format: "[TIMESTAMP] [LEVEL] [MODULE] Message"
  - [x] Add console handler to root logger with custom formatter

- [x] **Task 3: Add structured logging support** (AC: 6)
  - [x] Design logging metadata structure for future JSON output
  - [x] Add extra fields support in log records
  - [x] Ensure backward compatibility with console formatting
  - [x] Document metadata structure for future implementation

- [x] **Task 4: Integrate logging into existing components** (AC: 7, 8, 9)
  - [x] Add logging to RTSPCameraClient: connection events, frame capture
  - [x] Add logging to MotionDetector: motion detection events with confidence
  - [x] Add logging to ProcessingPipeline: frame processing, sampling decisions, metrics
  - [x] Add error logging with stack traces for exceptions
  - [x] Use appropriate log levels: INFO for key events, DEBUG for details, ERROR for exceptions

- [ ] **Task 5: Performance profiling and optimization** (AC: 10)
  - [ ] Create performance test script to measure logging overhead
  - [ ] Profile CPU impact at different log levels
  - [ ] Optimize logging calls to meet performance requirements (<2% INFO, <5% DEBUG)
  - [ ] Document performance characteristics

- [ ] **Task 6: Unit tests for logging functionality** (AC: 11)
  - [ ] Create `tests/unit/test_logging_config.py`
  - [ ] Test log level filtering (DEBUG vs INFO)
  - [ ] Test custom formatter output format
  - [ ] Test module name extraction
  - [ ] Mock logging output to verify correct messages

- [ ] **Task 7: Manual testing and validation** (AC: 12)
  - [ ] Test different log levels with sample execution
  - [ ] Verify DEBUG messages appear/disappear appropriately
  - [ ] Test error logging with stack traces
  - [ ] Document manual test procedures

## Dev Notes

### Architecture Considerations
- **Logging Levels**: Standard Python logging levels (DEBUG=10, INFO=20, WARNING=30, ERROR=40)
- **Module Naming**: Use short, consistent module names in brackets: [rtsp], [motion], [pipeline], [main]
- **Performance**: Logging should be lightweight - avoid expensive operations in log calls
- **Future Extensibility**: Design for JSON structured logging (Phase 2) with metadata fields
- **Configuration**: log_level in SystemConfig, validated via Pydantic enum

### Integration Points
- **SystemConfig**: Add log_level field with validation
- **Main Entry Point**: Call setup_logging() early in initialization
- **All Components**: Add appropriate logging calls throughout codebase
- **Error Handling**: Ensure exceptions are logged with full context

### Testing Strategy
- **Unit Tests**: Focus on configuration and formatter logic
- **Integration Tests**: Verify logging appears in system output
- **Performance Tests**: Measure overhead with profiling tools

### Dependencies
- **Python Standard Library**: logging module
- **Existing Code**: SystemConfig for configuration
- **Future Stories**: JSON logging (Phase 2), log rotation (Phase 3)

## PO Review

### Business Value Assessment
**HIGH VALUE** - Essential observability infrastructure for development and production monitoring. Enables:
- **Development**: Debug issues with frame-by-frame details and error stack traces
- **Production**: Monitor system health through key events and metrics
- **Troubleshooting**: Quick identification of connectivity, processing, and configuration issues
- **Future-Proofing**: Foundation for Phase 2 structured JSON logging

### Acceptance Criteria Validation
**COMPLETE & TESTABLE** - All 12 ACs are clear, measurable, and directly traceable to PRD requirements:
- Configuration and formatting requirements are specific and verifiable
- Performance requirements are quantifiable (<2% CPU overhead)
- Testing requirements include both automated unit tests and manual validation
- Future extensibility is designed in without over-engineering

### Technical Feasibility
**APPROVED** - Straightforward implementation using Python's mature logging framework:
- Standard library usage reduces external dependencies
- Existing logger instances already created in core components
- SystemConfig already includes log_level field
- Performance profiling tools readily available
- Custom formatting aligns with ISO standards

### Dependencies & Risks Assessment
**LOW RISK** - Minimal dependencies, well-isolated implementation:
- **Dependencies**: Only Python standard library + existing SystemConfig
- **Integration Points**: Clean integration with existing components
- **Risks**: Performance overhead (mitigated by profiling requirement), timezone handling (ISO 8601 standard addresses this)
- **Scope**: Focused on console logging only (JSON logging deferred to Phase 2)

### Story Size & Priority
**MEDIUM SIZE** (7 tasks, 12 ACs) - Appropriate scope for Epic 1 completion:
- **Effort**: 2-3 days development + testing
- **Priority**: HIGH - Critical for system observability and debugging
- **Dependencies**: None blocking, can be developed in parallel with other stories
- **Value Delivery**: Immediate developer productivity gains

### Approval Decision
**APPROVED FOR DEVELOPMENT** âœ…

**Rationale**: This story delivers essential observability infrastructure that will immediately improve developer experience and system maintainability. The implementation is well-scoped, technically sound, and aligns perfectly with PRD requirements. No blocking dependencies identified.

**Next Steps**: Proceed to development phase with Dev role.

## QA Results

*QA assessment will be performed after implementation is complete.*