# Story 5.5: Event Feed Component - Implementation Guide

**Story:** 5.5 - Event Feed Component
**Estimated Effort:** 10-12 hours (1.5 days)
**Prerequisites:** Stories 5.1, 5.2, 5.3, 5.4 completed

---

## Overview

This guide provides step-by-step instructions for implementing the **Event Feed Component**, which connects the dashboard frontend to the backend APIs (REST and WebSocket) to display motion detection events in real-time.

**Key Components:**
1. **WebSocketClient** - Manages WebSocket connection with reconnection logic
2. **ApiClient** - Handles REST API requests for historical events
3. **EventStore** - State management using Observer Pattern (~50 LOC)
4. **EventFeed** - Renders event cards with infinite scroll
5. **EventCard** - Individual event card component

**Architecture Pattern:**
- **Observer Pattern** for state management (no framework dependencies)
- **Service Layer** for API/WebSocket communication
- **Component-Based** architecture (ES6 modules)

---

## Pre-Implementation Checklist

Before starting implementation, verify:

- [ ] **Story 5.1 Complete:** FastAPI server runs on `http://localhost:8000`
- [ ] **Story 5.2 Complete:** REST API endpoints available (`/api/events`, `/api/images`)
- [ ] **Story 5.3 Complete:** WebSocket endpoint available at `ws://localhost:8000/ws/events`
- [ ] **Story 5.4 Complete:** Dashboard HTML/CSS structure in place
- [ ] **Database has events:** Run `sqlite3 surveillance.db "SELECT COUNT(*) FROM events;"` (should be > 0 for testing)
- [ ] **Modern browser:** Chrome 90+, Safari 14+, or Firefox 88+

---

## Implementation Steps

### Step 1: Create File Structure (5 minutes)

Create the following directory structure:

```bash
mkdir -p web/js/{state,services,components,utils}
```

**Verification:**
```bash
tree web/js/
# Should show:
# web/js/
# ‚îú‚îÄ‚îÄ app.js
# ‚îú‚îÄ‚îÄ state/
# ‚îú‚îÄ‚îÄ services/
# ‚îú‚îÄ‚îÄ components/
# ‚îî‚îÄ‚îÄ utils/
```

---

### Step 2: Implement EventStore (State Management) (30 minutes)

**File:** `web/js/state/EventStore.js`

**Purpose:** Centralized state management using Observer Pattern (no framework dependency)

**Key Features:**
- Store events array (max 500 events)
- Track connection status (connected/reconnecting/disconnected)
- Notify subscribers on state changes
- Prevent duplicate events

**Implementation:**

```javascript
// web/js/state/EventStore.js

class EventStore {
  constructor() {
    this.events = [];
    this.connectionStatus = 'disconnected';
    this.subscribers = [];
    this.maxEvents = 500; // Memory limit (NFR33)
  }

  // Observer Pattern: Subscribe to state changes
  subscribe(callback) {
    this.subscribers.push(callback);
    console.log(`[EventStore] Subscriber added (total: ${this.subscribers.length})`);

    // Return unsubscribe function
    return () => {
      this.subscribers = this.subscribers.filter(sub => sub !== callback);
      console.log(`[EventStore] Subscriber removed (total: ${this.subscribers.length})`);
    };
  }

  // Notify all subscribers of state change
  notify() {
    const state = {
      events: this.events,
      connectionStatus: this.connectionStatus,
      eventCount: this.events.length
    };

    console.log(`[EventStore] Notifying ${this.subscribers.length} subscribers`);
    this.subscribers.forEach(callback => {
      try {
        callback(state);
      } catch (error) {
        console.error('[EventStore] Subscriber callback failed:', error);
      }
    });
  }

  // Add new event (from WebSocket)
  addEvent(event) {
    // Check if event already exists (prevent duplicates)
    const exists = this.events.some(e => e.event_id === event.event_id);
    if (exists) {
      console.log('[EventStore] Duplicate event ignored:', event.event_id);
      return;
    }

    console.log('[EventStore] Adding new event:', event.event_id);

    // Add to beginning (newest first)
    this.events.unshift(event);

    // Enforce memory limit (NFR33: stable memory over 24h)
    if (this.events.length > this.maxEvents) {
      const removed = this.events.length - this.maxEvents;
      this.events = this.events.slice(0, this.maxEvents);
      console.log(`[EventStore] Trimmed ${removed} old events (limit: ${this.maxEvents})`);
    }

    this.notify();
  }

  // Add multiple events (from REST API)
  addEvents(events) {
    let addedCount = 0;

    events.forEach(event => {
      // Check if event already exists
      const exists = this.events.some(e => e.event_id === event.event_id);
      if (!exists) {
        this.events.push(event);
        addedCount++;
      }
    });

    console.log(`[EventStore] Added ${addedCount} events from API`);

    // Sort by timestamp (newest first)
    this.events.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // Enforce memory limit
    if (this.events.length > this.maxEvents) {
      const removed = this.events.length - this.maxEvents;
      this.events = this.events.slice(0, this.maxEvents);
      console.log(`[EventStore] Trimmed ${removed} old events (limit: ${this.maxEvents})`);
    }

    this.notify();
  }

  // Update connection status
  updateConnectionStatus(status) {
    if (this.connectionStatus !== status) {
      console.log(`[EventStore] Connection status: ${this.connectionStatus} ‚Üí ${status}`);
      this.connectionStatus = status;
      this.notify();
    }
  }

  // Get current state (for debugging)
  getState() {
    return {
      events: this.events,
      connectionStatus: this.connectionStatus,
      eventCount: this.events.length
    };
  }

  // Clear events (for testing)
  clear() {
    console.log('[EventStore] Clearing all events');
    this.events = [];
    this.notify();
  }
}

// Singleton instance
const eventStore = new EventStore();

export default eventStore;
```

**Verification:**
```javascript
// Browser console
import eventStore from './state/EventStore.js';

// Subscribe to changes
eventStore.subscribe((state) => {
  console.log('State updated:', state);
});

// Add test event
eventStore.addEvent({ event_id: 'test-1', timestamp: new Date().toISOString() });
// Should see console log: "State updated: { events: [...], connectionStatus: '...', eventCount: 1 }"
```

---

### Step 3: Implement ApiClient (REST API) (20 minutes)

**File:** `web/js/services/ApiClient.js`

**Purpose:** HTTP client for REST API endpoints from Story 5.2

**Implementation:**

```javascript
// web/js/services/ApiClient.js

class ApiClient {
  constructor(baseUrl = 'http://localhost:8000') {
    this.baseUrl = baseUrl;
  }

  async getEvents(params = {}) {
    const {
      limit = 100,
      offset = 0,
      start = null,
      end = null,
      camera_id = null
    } = params;

    // Build query string
    const query = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString()
    });

    if (start) query.append('start', start);
    if (end) query.append('end', end);
    if (camera_id) query.append('camera_id', camera_id);

    const url = `${this.baseUrl}/api/events?${query}`;

    console.log(`[API] GET ${url}`);

    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      console.log(`[API] Received ${data.events.length} events (total: ${data.total})`);
      return data;
    } catch (error) {
      console.error('[API] Request failed:', error);
      throw error;
    }
  }

  getImageUrl(eventId) {
    return `${this.baseUrl}/api/images/${eventId}`;
  }

  async getMetrics() {
    const url = `${this.baseUrl}/api/metrics`;

    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('[API] Metrics received:', data);
      return data;
    } catch (error) {
      console.error('[API] Metrics request failed:', error);
      throw error;
    }
  }

  async getConfig() {
    const url = `${this.baseUrl}/api/config`;

    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('[API] Config request failed:', error);
      throw error;
    }
  }
}

export default ApiClient;
```

**Verification:**
```javascript
// Browser console
import ApiClient from './services/ApiClient.js';
const api = new ApiClient();

// Test event fetch
const response = await api.getEvents({ limit: 10 });
console.log('Events:', response);
// Should see: { events: [...], total: X, limit: 10, offset: 0 }

// Test image URL
const imageUrl = api.getImageUrl('event-123');
console.log('Image URL:', imageUrl);
// Should see: http://localhost:8000/api/images/event-123
```

---

### Step 4: Implement WebSocketClient (Real-Time Updates) (45 minutes)

**File:** `web/js/services/WebSocketClient.js`

**Purpose:** Manage WebSocket connection with exponential backoff reconnection

**Critical Implementation Details:**
1. **Exponential Backoff:** 1s, 2s, 4s, 8s, 16s, max 30s
2. **Auto-Reconnect:** Automatically reconnect on disconnect
3. **Heartbeat:** Respond to ping messages with pong
4. **Thread-Safe:** Handle rapid connect/disconnect

**Implementation:**

```javascript
// web/js/services/WebSocketClient.js

class WebSocketClient {
  constructor(url, eventStore) {
    this.url = url;
    this.eventStore = eventStore;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectDelay = 30000; // 30 seconds
    this.reconnectTimer = null;
    this.isManualClose = false;
  }

  connect() {
    // Prevent multiple concurrent connections
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      console.log('[WebSocket] Already connected');
      return;
    }

    console.log(`[WebSocket] Connecting to ${this.url}...`);

    try {
      this.ws = new WebSocket(this.url);

      this.ws.onopen = () => {
        console.log('[WebSocket] Connected successfully');
        this.reconnectAttempts = 0;
        this.eventStore.updateConnectionStatus('connected');
      };

      this.ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);

          if (message.type === 'event') {
            console.log('[WebSocket] New event received:', message.data.event_id);
            this.eventStore.addEvent(message.data);
          } else if (message.type === 'ping') {
            // Respond to heartbeat
            this.ws.send(JSON.stringify({ type: 'pong' }));
            console.log('[WebSocket] Heartbeat: ping ‚Üí pong');
          } else {
            console.log('[WebSocket] Unknown message type:', message.type);
          }
        } catch (error) {
          console.error('[WebSocket] Failed to parse message:', error);
        }
      };

      this.ws.onerror = (error) => {
        console.error('[WebSocket] Error:', error);
      };

      this.ws.onclose = () => {
        console.log('[WebSocket] Connection closed');

        if (!this.isManualClose) {
          this.eventStore.updateConnectionStatus('disconnected');
          this.scheduleReconnect();
        }
      };
    } catch (error) {
      console.error('[WebSocket] Connection failed:', error);
      this.scheduleReconnect();
    }
  }

  scheduleReconnect() {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
    const delay = Math.min(
      1000 * Math.pow(2, this.reconnectAttempts),
      this.maxReconnectDelay
    );

    console.log(`[WebSocket] Reconnecting in ${delay / 1000}s (attempt ${this.reconnectAttempts + 1})`);
    this.eventStore.updateConnectionStatus('reconnecting');

    // Clear existing timer
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }

    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  disconnect() {
    console.log('[WebSocket] Manual disconnect');
    this.isManualClose = true;

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }

    this.eventStore.updateConnectionStatus('disconnected');
  }

  // Get connection status
  getStatus() {
    if (!this.ws) return 'disconnected';

    switch (this.ws.readyState) {
      case WebSocket.CONNECTING: return 'connecting';
      case WebSocket.OPEN: return 'connected';
      case WebSocket.CLOSING: return 'disconnecting';
      case WebSocket.CLOSED: return 'disconnected';
      default: return 'unknown';
    }
  }
}

export default WebSocketClient;
```

**Verification:**
```bash
# Terminal 1: Start web server
python web_server.py

# Browser console
import WebSocketClient from './services/WebSocketClient.js';
import eventStore from './state/EventStore.js';

const ws = new WebSocketClient('ws://localhost:8000/ws/events', eventStore);
ws.connect();

// Should see: "[WebSocket] Connecting to ws://localhost:8000/ws/events..."
// Should see: "[WebSocket] Connected successfully"

# Terminal 1: Stop server (Ctrl+C)
# Browser should see: "[WebSocket] Connection closed"
# Browser should see: "[WebSocket] Reconnecting in 1s (attempt 1)"

# Terminal 1: Restart server
# Browser should see: "[WebSocket] Connected successfully"
```

---

### Step 5: Implement Utility Functions (15 minutes)

**File:** `web/js/utils/formatters.js`

**Purpose:** Date/time formatting, confidence percentage

**Implementation:**

```javascript
// web/js/utils/formatters.js

export function formatTimestamp(timestamp) {
  const date = new Date(timestamp);

  // Format: "2025-11-10 14:30:45"
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');

  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

export function formatRelativeTime(timestamp) {
  const now = new Date();
  const date = new Date(timestamp);
  const diffMs = now - date;
  const diffSeconds = Math.floor(diffMs / 1000);

  if (diffSeconds < 60) return `${diffSeconds}s ago`;

  const diffMinutes = Math.floor(diffSeconds / 60);
  if (diffMinutes < 60) return `${diffMinutes}m ago`;

  const diffHours = Math.floor(diffMinutes / 60);
  if (diffHours < 24) return `${diffHours}h ago`;

  const diffDays = Math.floor(diffHours / 24);
  return `${diffDays}d ago`;
}

export function formatConfidence(confidence) {
  // confidence is 0-1, convert to percentage
  return `${Math.round(confidence * 100)}%`;
}

export function formatFileSize(bytes) {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
```

**Verification:**
```javascript
// Browser console
import { formatTimestamp, formatRelativeTime, formatConfidence } from './utils/formatters.js';

formatTimestamp('2025-11-10T14:30:45Z');
// Output: "2025-11-10 14:30:45"

formatRelativeTime(new Date(Date.now() - 120000).toISOString());
// Output: "2m ago"

formatConfidence(0.8743);
// Output: "87%"
```

---

### Step 6: Implement EventCard Component (30 minutes)

**File:** `web/js/components/EventCard.js`

**Purpose:** Render individual event card with image, timestamp, camera, objects

**Implementation:**

```javascript
// web/js/components/EventCard.js

import ApiClient from '../services/ApiClient.js';
import { formatTimestamp, formatConfidence } from '../utils/formatters.js';

const apiClient = new ApiClient();

export function createEventCard(event) {
  const card = document.createElement('article');
  card.className = 'event-card';
  card.setAttribute('data-event-id', event.event_id);
  card.setAttribute('role', 'article');
  card.setAttribute('aria-label', `Event from ${event.camera_id} at ${formatTimestamp(event.timestamp)}`);

  // Image container
  const imageContainer = document.createElement('div');
  imageContainer.className = 'event-card-image';

  const img = document.createElement('img');
  img.src = apiClient.getImageUrl(event.event_id);
  img.alt = `Event from ${event.camera_id}`;
  img.loading = 'lazy'; // Lazy load for performance

  // Fallback for missing images
  img.onerror = () => {
    img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect fill="%233a3a3a" width="300" height="200"/%3E%3Ctext fill="%23808080" x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle"%3ENo Image%3C/text%3E%3C/svg%3E';
  };

  imageContainer.appendChild(img);

  // Card content
  const content = document.createElement('div');
  content.className = 'event-card-content';

  // Header (camera + timestamp)
  const header = document.createElement('div');
  header.className = 'event-card-header';

  const cameraSpan = document.createElement('span');
  cameraSpan.className = 'camera-id';
  cameraSpan.textContent = event.camera_id;

  const timestampSpan = document.createElement('span');
  timestampSpan.className = 'timestamp';
  timestampSpan.textContent = formatTimestamp(event.timestamp);

  header.appendChild(cameraSpan);
  header.appendChild(timestampSpan);

  // Detected objects
  const objects = parseDetectedObjects(event.detected_objects);
  const objectsDiv = document.createElement('div');
  objectsDiv.className = 'detected-objects';

  if (objects.length > 0) {
    const objectsCount = document.createElement('p');
    objectsCount.className = 'objects-count';
    objectsCount.textContent = `${objects.length} object${objects.length > 1 ? 's' : ''} detected:`;

    const objectsList = document.createElement('ul');
    objectsList.className = 'objects-list';

    objects.forEach(obj => {
      const li = document.createElement('li');

      const nameSpan = document.createElement('span');
      nameSpan.className = 'object-name';
      nameSpan.textContent = obj.name;

      const confidenceSpan = document.createElement('span');
      confidenceSpan.className = 'object-confidence';
      confidenceSpan.textContent = formatConfidence(obj.confidence);

      li.appendChild(nameSpan);
      li.appendChild(confidenceSpan);
      objectsList.appendChild(li);
    });

    objectsDiv.appendChild(objectsCount);
    objectsDiv.appendChild(objectsList);
  } else {
    const noObjects = document.createElement('p');
    noObjects.className = 'objects-count';
    noObjects.textContent = 'No objects detected';
    objectsDiv.appendChild(noObjects);
  }

  // Assemble card
  content.appendChild(header);
  content.appendChild(objectsDiv);
  card.appendChild(imageContainer);
  card.appendChild(content);

  // Fade-in animation for new events
  card.style.animation = 'fadeIn 0.3s ease-in';

  return card;
}

function parseDetectedObjects(jsonString) {
  if (!jsonString) return [];

  try {
    const objects = JSON.parse(jsonString);

    // Sort by confidence (highest first)
    return objects.sort((a, b) => b.confidence - a.confidence);
  } catch (error) {
    console.error('[EventCard] Failed to parse detected_objects:', error);
    return [];
  }
}
```

**Verification:**
```javascript
// Browser console
import { createEventCard } from './components/EventCard.js';

const testEvent = {
  event_id: 'test-123',
  camera_id: 'Camera 1',
  timestamp: '2025-11-10T14:30:45Z',
  detected_objects: JSON.stringify([
    { name: 'person', confidence: 0.95 },
    { name: 'car', confidence: 0.87 }
  ])
};

const card = createEventCard(testEvent);
document.querySelector('.main-content').appendChild(card);
// Should see event card rendered in main content area
```

---

### Step 7: Implement EventFeed Component (60 minutes)

**File:** `web/js/components/EventFeed.js`

**Purpose:** Render event feed with infinite scroll, loading states, error handling

**Implementation:**

```javascript
// web/js/components/EventFeed.js

import eventStore from '../state/EventStore.js';
import { createEventCard } from './EventCard.js';
import ApiClient from '../services/ApiClient.js';

class EventFeed {
  constructor(containerSelector) {
    this.container = document.querySelector(containerSelector);
    if (!this.container) {
      throw new Error(`Container not found: ${containerSelector}`);
    }

    this.apiClient = new ApiClient();
    this.isLoading = false;
    this.hasMore = true;
    this.offset = 0;
    this.renderedEventIds = new Set(); // Track rendered events

    // Subscribe to state changes
    this.unsubscribe = eventStore.subscribe((state) => {
      this.render(state.events);
    });

    // Setup infinite scroll
    this.setupInfiniteScroll();

    console.log('[EventFeed] Initialized');
  }

  async loadInitialEvents() {
    console.log('[EventFeed] Loading initial events...');
    this.showLoading();

    try {
      const response = await this.apiClient.getEvents({ limit: 100 });
      eventStore.addEvents(response.events);
      this.offset = response.events.length;
      this.hasMore = response.total > response.events.length;

      console.log(`[EventFeed] Loaded ${response.events.length} events (total: ${response.total})`);
    } catch (error) {
      this.showError('Failed to load events. Please refresh the page.');
      console.error('[EventFeed] Initial load failed:', error);
    } finally {
      this.hideLoading();
    }
  }

  async loadMoreEvents() {
    if (this.isLoading || !this.hasMore) {
      console.log('[EventFeed] Skip load more (loading:', this.isLoading, 'hasMore:', this.hasMore, ')');
      return;
    }

    console.log(`[EventFeed] Loading more events (offset: ${this.offset})...`);
    this.isLoading = true;
    this.showLoadingMore();

    try {
      const response = await this.apiClient.getEvents({
        limit: 50,
        offset: this.offset
      });

      eventStore.addEvents(response.events);
      this.offset += response.events.length;
      this.hasMore = this.offset < response.total;

      console.log(`[EventFeed] Loaded ${response.events.length} more events (total: ${response.total}, offset: ${this.offset})`);
    } catch (error) {
      console.error('[EventFeed] Load more failed:', error);
    } finally {
      this.isLoading = false;
      this.hideLoadingMore();
    }
  }

  setupInfiniteScroll() {
    // Use debounce to prevent excessive API calls
    let scrollTimer = null;

    this.container.addEventListener('scroll', () => {
      if (scrollTimer) {
        clearTimeout(scrollTimer);
      }

      scrollTimer = setTimeout(() => {
        const scrollTop = this.container.scrollTop;
        const scrollHeight = this.container.scrollHeight;
        const clientHeight = this.container.clientHeight;

        // Trigger when within 200px of bottom
        const threshold = 200;
        if (scrollHeight - scrollTop - clientHeight < threshold) {
          console.log('[EventFeed] Scroll threshold reached, loading more...');
          this.loadMoreEvents();
        }
      }, 100); // 100ms debounce
    });

    console.log('[EventFeed] Infinite scroll enabled');
  }

  render(events) {
    if (events.length === 0) {
      this.showEmptyState();
      return;
    }

    // Get feed container (not loading/error container)
    let feedContainer = this.container.querySelector('.event-feed-container');
    if (!feedContainer) {
      feedContainer = document.createElement('div');
      feedContainer.className = 'event-feed-container';
      this.container.innerHTML = '';
      this.container.appendChild(feedContainer);
    }

    // Render new events only (prevent re-rendering all events)
    events.forEach(event => {
      if (!this.renderedEventIds.has(event.event_id)) {
        const card = createEventCard(event);
        feedContainer.insertBefore(card, feedContainer.firstChild);
        this.renderedEventIds.add(event.event_id);
      }
    });

    console.log(`[EventFeed] Rendered ${this.renderedEventIds.size} total events`);
  }

  showLoading() {
    this.container.innerHTML = `
      <div class="loading-state">
        <div class="spinner"></div>
        <p>Loading events...</p>
      </div>
    `;
  }

  hideLoading() {
    const loadingState = this.container.querySelector('.loading-state');
    if (loadingState) {
      loadingState.remove();
    }
  }

  showLoadingMore() {
    const existing = this.container.querySelector('.loading-more');
    if (existing) return;

    const loadingMore = document.createElement('div');
    loadingMore.className = 'loading-more';
    loadingMore.innerHTML = `
      <div class="spinner"></div>
      <p>Loading more events...</p>
    `;
    this.container.appendChild(loadingMore);
  }

  hideLoadingMore() {
    const loadingMore = this.container.querySelector('.loading-more');
    if (loadingMore) {
      loadingMore.remove();
    }
  }

  showEmptyState() {
    this.container.innerHTML = `
      <div class="empty-state">
        <div class="empty-icon">üìπ</div>
        <h3>No events yet</h3>
        <p>Waiting for motion detection...</p>
      </div>
    `;
  }

  showError(message) {
    this.container.innerHTML = `
      <div class="error-state">
        <div class="error-icon">‚ö†Ô∏è</div>
        <h3>Error</h3>
        <p>${message}</p>
        <button class="btn-retry" onclick="location.reload()">Retry</button>
      </div>
    `;
  }

  destroy() {
    console.log('[EventFeed] Destroying...');
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

export default EventFeed;
```

---

### Step 8: Implement Application Bootstrap (30 minutes)

**File:** `web/js/app.js`

**Purpose:** Initialize dashboard, connect WebSocket, load initial events

**Implementation:**

```javascript
// web/js/app.js

import eventStore from './state/EventStore.js';
import WebSocketClient from './services/WebSocketClient.js';
import EventFeed from './components/EventFeed.js';

class App {
  constructor() {
    this.wsClient = null;
    this.eventFeed = null;
  }

  async init() {
    console.log('[App] Initializing dashboard...');

    try {
      // Initialize event feed component
      this.eventFeed = new EventFeed('.main-content');

      // Load initial events from REST API
      await this.eventFeed.loadInitialEvents();

      // Connect to WebSocket for real-time updates
      this.wsClient = new WebSocketClient('ws://localhost:8000/ws/events', eventStore);
      this.wsClient.connect();

      // Subscribe to connection status for header update
      eventStore.subscribe((state) => {
        this.updateConnectionStatus(state.connectionStatus);
        this.updateEventCount(state.eventCount);
      });

      console.log('[App] Dashboard ready');
    } catch (error) {
      console.error('[App] Initialization failed:', error);
    }
  }

  updateConnectionStatus(status) {
    const statusElement = document.querySelector('.connection-status');
    if (!statusElement) {
      console.warn('[App] Connection status element not found');
      return;
    }

    const statusDot = statusElement.querySelector('.status-dot');
    const statusText = statusElement.querySelector('.status-text');

    if (!statusDot || !statusText) {
      console.warn('[App] Status dot or text not found');
      return;
    }

    if (status === 'connected') {
      statusDot.className = 'status-dot connected';
      statusText.textContent = 'Connected';
    } else if (status === 'reconnecting') {
      statusDot.className = 'status-dot reconnecting';
      statusText.textContent = 'Reconnecting...';
    } else {
      statusDot.className = 'status-dot disconnected';
      statusText.textContent = 'Disconnected';
    }
  }

  updateEventCount(count) {
    const countElement = document.querySelector('.event-count');
    if (countElement) {
      countElement.textContent = `${count} events`;
    }
  }

  destroy() {
    console.log('[App] Shutting down...');
    if (this.wsClient) {
      this.wsClient.disconnect();
    }
    if (this.eventFeed) {
      this.eventFeed.destroy();
    }
  }
}

// Initialize app when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    const app = new App();
    app.init();

    // Expose app for debugging
    window.app = app;
  });
} else {
  const app = new App();
  app.init();

  // Expose app for debugging
  window.app = app;
}

// Expose eventStore for debugging
window.eventStore = eventStore;
```

---

### Step 9: Update HTML to Load JavaScript Modules (10 minutes)

**File:** `web/index.html`

Add script tags before `</body>`:

```html
<!-- Before </body> -->

<!-- Load app as ES6 module -->
<script type="module" src="/static/js/app.js"></script>
```

**Important:** Ensure FastAPI serves JavaScript with correct MIME type:

```python
# web_server.py (from Story 5.1)

from fastapi.staticfiles import StaticFiles

app.mount("/static", StaticFiles(directory="web"), name="static")
```

---

### Step 10: Manual Testing (30 minutes)

**Test 1: Initial Load**

```bash
# Terminal 1: Start web server
python web_server.py

# Open http://localhost:8000 in browser
# Expected: Events load within 3 seconds
# Expected: Status shows "Connected" (green dot)
# Expected: Event cards displayed in feed
```

**Test 2: Real-Time Updates**

```bash
# Terminal 1: Start main application
python main.py

# Terminal 2: Start web server
python web_server.py

# Browser: Open http://localhost:8000

# Trigger motion detection (move in front of camera)
# Expected: New event appears within 1 second
# Expected: Event card animates in at top of feed
```

**Test 3: Reconnection Logic**

```bash
# Start web server and open dashboard
python web_server.py

# Browser: Verify "Connected" status

# Stop web server (Ctrl+C)
# Expected: Status changes to "Reconnecting..." (orange dot)

# Restart web server
python web_server.py

# Expected: Status changes to "Connected" within 30 seconds
```

**Test 4: Infinite Scroll**

```bash
# Ensure database has 150+ events
sqlite3 surveillance.db "SELECT COUNT(*) FROM events;"

# Open dashboard
# Scroll to bottom of event feed
# Expected: Loading spinner appears
# Expected: 50 more events load and display
```

**Test 5: Empty State**

```bash
# Clear events
sqlite3 surveillance.db "DELETE FROM events;"

# Open dashboard
# Expected: Empty state message displayed
# Expected: "No events yet. Waiting for motion detection..."
```

**Test 6: Image Fallback**

```bash
# Break image path
sqlite3 surveillance.db "UPDATE events SET image_path = '/nonexistent.jpg' WHERE id = 1;"

# Open dashboard
# Expected: Placeholder image displayed (not broken image icon)
```

---

## Common Issues and Solutions

### Issue 1: CORS Errors

**Symptom:** Browser console shows `CORS policy: No 'Access-Control-Allow-Origin' header`

**Solution:**

```python
# web_server.py
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:8000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

### Issue 2: WebSocket Not Connecting

**Symptom:** Browser console shows `WebSocket connection failed`

**Diagnosis:**

```javascript
// Browser console
const ws = new WebSocket('ws://localhost:8000/ws/events');
ws.onopen = () => console.log('Connected');
ws.onerror = (err) => console.error('Error:', err);
```

**Solution:**
- Verify web server is running: `curl http://localhost:8000/api/health`
- Check WebSocket endpoint: `curl http://localhost:8000/docs` (FastAPI docs)
- Ensure Story 5.3 WebSocket implementation is complete

---

### Issue 3: Events Not Displaying

**Symptom:** Dashboard loads but no events appear

**Diagnosis:**

```bash
# Check database
sqlite3 surveillance.db "SELECT COUNT(*) FROM events;"
# Should return > 0

# Check API endpoint
curl http://localhost:8000/api/events?limit=10
# Should return JSON with events array
```

**Solution:**
- Ensure database has events: Run `python main.py` to generate events
- Check browser console for errors
- Verify API endpoint returns data

---

### Issue 4: Memory Leak Over Time

**Symptom:** Browser memory usage grows continuously

**Diagnosis:**

```javascript
// Browser DevTools > Performance > Memory
// Record memory over 1 hour
// Memory should stabilize after initial load

// Check in-memory event count
console.log(window.eventStore.events.length);
// Should be ‚â§ 500
```

**Solution:**
- Verify `EventStore.maxEvents = 500` is enforced
- Check for event listener leaks (use `unsubscribe()`)
- Ensure `renderedEventIds` Set doesn't grow unbounded

---

### Issue 5: Infinite Scroll Not Working

**Symptom:** Scrolling to bottom doesn't load more events

**Diagnosis:**

```javascript
// Browser console
const container = document.querySelector('.main-content');
console.log({
  scrollTop: container.scrollTop,
  scrollHeight: container.scrollHeight,
  clientHeight: container.clientHeight
});
// scrollHeight - scrollTop - clientHeight should be < 200 at bottom
```

**Solution:**
- Verify `.main-content` has `overflow-y: auto;` in CSS
- Check `hasMore` flag: `console.log(window.app.eventFeed.hasMore)`
- Ensure API returns `total` field in response

---

## Performance Optimization

### 1. Lazy Image Loading

Already implemented with `loading="lazy"` attribute:

```javascript
img.loading = 'lazy';
```

### 2. Debounced Scroll Handling

Already implemented with 100ms debounce:

```javascript
setTimeout(() => {
  // Check scroll position
}, 100);
```

### 3. Memory Limit Enforcement

EventStore limits to 500 events:

```javascript
if (this.events.length > this.maxEvents) {
  this.events = this.events.slice(0, this.maxEvents);
}
```

### 4. Efficient Rendering

Only render new events (avoid re-rendering all):

```javascript
events.forEach(event => {
  if (!this.renderedEventIds.has(event.event_id)) {
    const card = createEventCard(event);
    feedContainer.insertBefore(card, feedContainer.firstChild);
    this.renderedEventIds.add(event.event_id);
  }
});
```

---

## Browser Compatibility

**Minimum Versions:**
- Chrome 90+ (May 2021)
- Safari 14+ (September 2020)
- Firefox 88+ (April 2021)

**Required Features:**
- ES6 Modules (`import/export`)
- `async/await`
- WebSocket API
- Fetch API
- CSS Grid
- CSS Flexbox

**Verification:**

```bash
# Check browser support
# Open https://caniuse.com/
# Search: "ES6 modules", "WebSocket", "CSS Grid"
```

---

## Accessibility Checklist

- [ ] Semantic HTML (`<article>`, `<header>`, etc.)
- [ ] ARIA labels for dynamic content
- [ ] `aria-live="polite"` for event announcements
- [ ] Keyboard navigation (Tab through cards)
- [ ] Focus indicators visible
- [ ] WCAG AA contrast ratios (4.5:1)
- [ ] Alt text for images

**Verification:**

```bash
# Enable screen reader
# macOS: System Preferences > Accessibility > VoiceOver
# Windows: Start > NVDA

# Navigate dashboard with Tab key
# Should hear event details announced
```

---

## Deployment Checklist

- [ ] All JavaScript files created and tested
- [ ] CSS additions applied to `components.css`
- [ ] HTML updated with script tags
- [ ] Manual tests completed (6 test cases)
- [ ] Browser console shows no errors
- [ ] WebSocket connects on page load
- [ ] Events load within 3 seconds (NFR31)
- [ ] Real-time events appear within 1 second (NFR32)
- [ ] Memory stable under 100MB over 24 hours (NFR33)
- [ ] WCAG AA accessibility verified (NFR34)

---

## Next Steps

After completing Story 5.5:

1. **Story 5.6: System Health Display** - Populate metrics panel with real data
2. **Story 5.7: Event Detail Modal** - Click event cards to see full details
3. **Story 5.8: Search and Filtering** - Filter events by camera, time range, objects

---

## Related Documentation

- **Story Document:** `docs/stories/5.5.story.md`
- **Story 5.3:** Real-Time Event Streaming (WebSocket implementation)
- **Story 5.2:** Event API Endpoints (REST API)
- **Story 5.4:** Dashboard HTML/CSS Framework (layout structure)

---

## Change Log

| Date | Version | Changes | Author |
|------|---------|---------|--------|
| 2025-11-10 | 1.0 | Initial implementation guide | Winston (Architect) |
