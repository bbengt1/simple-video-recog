# Story 5.3: Real-Time Event Streaming

**Status:** Ready for Development

## Story

**As a** user,
**I want** live event updates without page refresh via WebSocket,
**so that** I can monitor events in real-time as they happen (<1s latency, NFR31).

## Business Value

This story delivers real-time monitoring capabilities, transforming the dashboard from a static view to a live monitoring system:
- Events appear on dashboard within 1 second of detection
- No page refresh or polling required (reduces server load 95%)
- Live notification system for security events
- Foundation for interactive features (pause/resume in Epic 6)
- Professional real-time dashboard experience

## Acceptance Criteria

### 1. WebSocket Endpoint
- WebSocket endpoint created at `ws://localhost:8000/ws/events`
- Accepts connections from dashboard clients
- Validates origin (localhost only for security)
- Connection established with 3-way handshake
- Supports multiple simultaneous client connections

### 2. Connection Manager
- `WebSocketManager` class created in `api/websocket.py`
- Tracks active WebSocket connections in memory
- Adds clients on connect, removes on disconnect
- Thread-safe connection list (concurrent access safe)
- Broadcasts messages to all connected clients

### 3. Event Broadcasting
- New events broadcast to all connected WebSocket clients
- Message format: `{"type": "event", "data": {...}}`
- Event data matches `Event` Pydantic model from Story 5.2
- Broadcast latency <100ms from EventManager to client
- Failed sends to disconnected clients handled gracefully

### 4. EventManager Integration
- `EventManager` updated to publish events via WebSocket
- WebSocket manager injected via dependency injection
- Publishing is optional (doesn't fail if WebSocket unavailable)
- No changes to database persistence (WebSocket is additional)
- Backward compatible with existing event creation flow

### 5. Connection Lifecycle
- Client connect: Add to connection list, log connection
- Client disconnect: Remove from list, log disconnection
- Server shutdown: Close all connections gracefully
- Heartbeat: Ping clients every 30 seconds to detect stale connections
- Automatic cleanup of dead connections

### 6. Error Handling
- Connection errors logged but don't crash server
- Malformed messages from clients logged and ignored
- Broadcast errors for specific clients handled individually
- Dead connection cleanup automatic
- Error messages sent to client: `{"type": "error", "message": "..."}`

### 7. Message Format
- Event messages: `{"type": "event", "data": {Event model}}`
- Error messages: `{"type": "error", "message": "description"}`
- Ping messages: `{"type": "ping", "timestamp": "ISO 8601"}`
- Pong response: `{"type": "pong", "timestamp": "ISO 8601"}`
- All messages are valid JSON

### 8. Client Reconnection Support
- Server sends ping every 30 seconds
- Client should respond with pong (client-side Story 5.5)
- No message replay (clients query REST API for missed events)
- Connection ID logged for debugging
- Connection metrics tracked (total connections, active connections)

### 9. Performance Requirements
- Broadcast latency <100ms to all clients
- Memory usage <10MB per 100 connected clients
- No memory leaks (connections properly cleaned up)
- CPU overhead <2% for WebSocket operations
- Handles 100 simultaneous connections without degradation

### 10. Integration with Story 5.2
- Uses `Event` Pydantic model for message serialization
- No duplicate code for event serialization
- WebSocket route added to same FastAPI app
- OpenAPI docs updated to show WebSocket endpoint

### 11. Logging and Monitoring
- Connection events logged (connect, disconnect)
- Broadcast events logged at DEBUG level
- Connection count tracked in metrics
- Errors logged at ERROR level with stack trace
- Request ID included in all log messages

### 12. Testing
- Unit tests for WebSocketManager (connect, disconnect, broadcast)
- Integration test for full WebSocket lifecycle
- Manual test with browser WebSocket client
- Load test with 100 simultaneous connections
- Reconnection test (server restart while clients connected)

## Technical Specifications

### WebSocket Endpoint

```python
# api/routes/stream.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from datetime import datetime
import logging
import json

from api.websocket import WebSocketManager

router = APIRouter()
logger = logging.getLogger(__name__)

# Module-level WebSocket manager singleton
ws_manager = WebSocketManager()

@router.websocket("/ws/events")
async def websocket_events(websocket: WebSocket):
    """
    WebSocket endpoint for real-time event streaming.

    Clients connect to receive live event updates as they occur.
    Connection remains open until client disconnects or server shuts down.
    """
    connection_id = None

    try:
        # Accept connection
        await websocket.accept()
        connection_id = ws_manager.connect(websocket)

        logger.info(f"[{connection_id}] WebSocket connected")

        # Send initial ping
        await websocket.send_json({
            "type": "ping",
            "timestamp": datetime.now().isoformat()
        })

        # Keep connection alive and handle client messages
        while True:
            try:
                # Wait for client messages (pong responses, etc.)
                data = await websocket.receive_text()
                message = json.loads(data)

                if message.get("type") == "pong":
                    logger.debug(f"[{connection_id}] Received pong")
                else:
                    logger.warning(f"[{connection_id}] Unknown message type: {message.get('type')}")

            except json.JSONDecodeError:
                logger.warning(f"[{connection_id}] Received invalid JSON")
                await websocket.send_json({
                    "type": "error",
                    "message": "Invalid JSON format"
                })

    except WebSocketDisconnect:
        logger.info(f"[{connection_id}] WebSocket disconnected")

    except Exception as e:
        logger.error(f"[{connection_id}] WebSocket error: {e}", exc_info=True)

    finally:
        if connection_id:
            ws_manager.disconnect(connection_id)
            logger.info(f"[{connection_id}] Connection closed")


def get_websocket_manager() -> WebSocketManager:
    """Get WebSocket manager singleton."""
    return ws_manager
```

---

### WebSocket Manager

```python
# api/websocket.py
from fastapi import WebSocket
from typing import Dict
import asyncio
import logging
import uuid
from datetime import datetime

logger = logging.getLogger(__name__)

class WebSocketManager:
    """
    Manages WebSocket connections and broadcasts events to all connected clients.

    Thread-safe connection management with automatic cleanup of dead connections.
    """

    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self._lock = asyncio.Lock()
        self._heartbeat_task = None

    def connect(self, websocket: WebSocket) -> str:
        """
        Add a new WebSocket connection.

        Returns:
            connection_id: Unique identifier for this connection
        """
        connection_id = f"ws_{uuid.uuid4().hex[:8]}"
        self.active_connections[connection_id] = websocket
        logger.info(f"Connection added: {connection_id} (total: {len(self.active_connections)})")
        return connection_id

    def disconnect(self, connection_id: str):
        """Remove a WebSocket connection."""
        if connection_id in self.active_connections:
            del self.active_connections[connection_id]
            logger.info(f"Connection removed: {connection_id} (total: {len(self.active_connections)})")

    async def broadcast_event(self, event_data: dict):
        """
        Broadcast event to all connected clients.

        Args:
            event_data: Event dictionary matching Event Pydantic model
        """
        if not self.active_connections:
            logger.debug("No active connections to broadcast to")
            return

        message = {
            "type": "event",
            "data": event_data
        }

        logger.debug(f"Broadcasting event to {len(self.active_connections)} clients")

        # Broadcast to all clients, handle individual failures
        dead_connections = []

        async with self._lock:
            for connection_id, websocket in self.active_connections.items():
                try:
                    await websocket.send_json(message)
                    logger.debug(f"[{connection_id}] Event sent successfully")

                except Exception as e:
                    logger.warning(f"[{connection_id}] Failed to send event: {e}")
                    dead_connections.append(connection_id)

        # Clean up dead connections
        for connection_id in dead_connections:
            self.disconnect(connection_id)

    async def send_ping_to_all(self):
        """Send ping to all connected clients to detect stale connections."""
        if not self.active_connections:
            return

        ping_message = {
            "type": "ping",
            "timestamp": datetime.now().isoformat()
        }

        logger.debug(f"Sending ping to {len(self.active_connections)} clients")

        dead_connections = []

        async with self._lock:
            for connection_id, websocket in self.active_connections.items():
                try:
                    await websocket.send_json(ping_message)
                except Exception as e:
                    logger.warning(f"[{connection_id}] Ping failed: {e}")
                    dead_connections.append(connection_id)

        for connection_id in dead_connections:
            self.disconnect(connection_id)

    async def start_heartbeat(self, interval: int = 30):
        """
        Start heartbeat task to ping clients periodically.

        Args:
            interval: Seconds between pings (default: 30)
        """
        while True:
            await asyncio.sleep(interval)
            await self.send_ping_to_all()

    def get_connection_count(self) -> int:
        """Get number of active connections."""
        return len(self.active_connections)

    async def close_all(self):
        """Close all WebSocket connections gracefully."""
        logger.info(f"Closing all connections ({len(self.active_connections)})")

        async with self._lock:
            for connection_id, websocket in self.active_connections.items():
                try:
                    await websocket.close()
                    logger.info(f"[{connection_id}] Connection closed")
                except Exception as e:
                    logger.warning(f"[{connection_id}] Error closing connection: {e}")

            self.active_connections.clear()
```

---

### EventManager Integration

```python
# core/event_manager.py (UPDATE)
from typing import Optional
import logging

from core.database import DatabaseManager
from core.json_logger import JSONEventLogger
from core.plaintext_logger import PlaintextEventLogger

logger = logging.getLogger(__name__)

class EventManager:
    """
    Manages event creation, de-duplication, and persistence.

    Updated in Story 5.3 to support WebSocket broadcasting.
    """

    def __init__(
        self,
        db_manager: DatabaseManager,
        json_logger: JSONEventLogger,
        txt_logger: PlaintextEventLogger,
        websocket_manager=None  # NEW: Optional WebSocket support
    ):
        self.db_manager = db_manager
        self.json_logger = json_logger
        self.txt_logger = txt_logger
        self.websocket_manager = websocket_manager  # NEW
        self.suppression_cache = []
        self.suppression_threshold = 0.8

    def create_event(self, frame, objects, description) -> Optional['Event']:
        """
        Create event and persist to all outputs.

        Updated in Story 5.3 to broadcast via WebSocket.
        """
        from core.models import Event
        import time
        import uuid

        # Create event
        event = Event(
            event_id=f"evt_{int(time.time())}_{uuid.uuid4().hex[:5]}",
            timestamp=datetime.now(),
            camera_id="camera_1",  # TODO: From config
            detected_objects=objects,
            llm_description=description,
            image_path="...",  # Saved elsewhere
        )

        # Check suppression
        if self.should_suppress(event):
            logger.debug(f"Event suppressed: {event.event_id}")
            return None

        # Persist to database and logs
        try:
            self.db_manager.insert_event(event)
            self.json_logger.log_event(event)
            self.txt_logger.log_event(event)
            logger.info(f"Event created: {event.event_id}")

        except Exception as e:
            logger.error(f"Failed to persist event: {e}")
            raise

        # NEW: Broadcast to WebSocket clients
        if self.websocket_manager:
            try:
                # Convert Event to dict for JSON serialization
                event_dict = event.model_dump(mode='json')

                # Broadcast asynchronously (non-blocking)
                import asyncio
                asyncio.create_task(
                    self.websocket_manager.broadcast_event(event_dict)
                )
                logger.debug(f"Event broadcast to WebSocket: {event.event_id}")

            except Exception as e:
                # WebSocket errors should not fail event creation
                logger.warning(f"WebSocket broadcast failed: {e}")

        return event

    def should_suppress(self, event: 'Event') -> bool:
        """Check if event should be suppressed (de-duplication logic)."""
        # Implementation from existing code
        # ... (unchanged)
        return False
```

---

### FastAPI App Integration

```python
# api/app.py (UPDATE)
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pathlib import Path
import logging
import asyncio

from core.config import load_config
from api.routes import health, events, metrics, stream  # NEW: Add stream
from api.websocket import WebSocketManager

logger = logging.getLogger(__name__)

def create_app() -> FastAPI:
    """Create and configure FastAPI application."""

    # Load configuration
    config = load_config("config/config.yaml")

    # Create FastAPI app
    app = FastAPI(
        title="Local Video Recognition System API",
        version="1.0.0",
        description="REST API and WebSocket for event access and real-time monitoring",
        docs_url="/docs",
        redoc_url="/redoc"
    )

    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:8000", "http://127.0.0.1:8000"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Include routers
    app.include_router(health.router, prefix="/api", tags=["health"])
    app.include_router(events.router, prefix="/api", tags=["events"])
    app.include_router(metrics.router, prefix="/api", tags=["metrics"])
    app.include_router(stream.router, prefix="", tags=["websocket"])  # NEW: No prefix for /ws

    # Mount static files
    web_dir = Path(__file__).parent.parent / "web"
    if web_dir.exists():
        app.mount("/css", StaticFiles(directory=web_dir / "css"), name="css")
        app.mount("/js", StaticFiles(directory=web_dir / "js"), name="js")

        # Serve index.html at root
        from fastapi.responses import FileResponse

        @app.get("/")
        async def read_root():
            return FileResponse(web_dir / "index.html")

    # Mount event images
    events_dir = Path("data/events")
    if events_dir.exists():
        app.mount("/images", StaticFiles(directory=events_dir), name="images")

    # NEW: Startup event to start WebSocket heartbeat
    @app.on_event("startup")
    async def startup_event():
        from api.routes.stream import get_websocket_manager
        ws_manager = get_websocket_manager()
        asyncio.create_task(ws_manager.start_heartbeat(interval=30))
        logger.info("WebSocket heartbeat task started")

    # NEW: Shutdown event to close all WebSocket connections
    @app.on_event("shutdown")
    async def shutdown_event():
        from api.routes.stream import get_websocket_manager
        ws_manager = get_websocket_manager()
        await ws_manager.close_all()
        logger.info("All WebSocket connections closed")

    logger.info("FastAPI application created with WebSocket support")
    return app

app = create_app()
```

---

### Main Application Integration

```python
# main.py (UPDATE - where EventManager is created)

# At the point where EventManager is instantiated:
from api.routes.stream import get_websocket_manager

# Get WebSocket manager if web server is running
# (In practice, this would be None if only main.py is running without web server)
try:
    ws_manager = get_websocket_manager()
except Exception:
    ws_manager = None  # Web server not running, that's okay

# Create EventManager with optional WebSocket support
event_manager = EventManager(
    db_manager=db_manager,
    json_logger=json_logger,
    txt_logger=txt_logger,
    websocket_manager=ws_manager  # NEW: Pass WebSocket manager
)

logger.info(f"EventManager created (WebSocket: {'enabled' if ws_manager else 'disabled'})")
```

## Dependencies

### Prerequisites
- Story 5.1 complete (FastAPI server setup)
- Story 5.2 complete (Event Pydantic models)
- Understanding of WebSocket protocol
- Understanding of async/await in Python

### Blocked By
- Story 5.1: FastAPI Server Setup (REQUIRED)
- Story 5.2: Event API Endpoints (REQUIRED - needs Event model)

### Blocks
- Story 5.4: Dashboard HTML/CSS Framework (can proceed in parallel)
- Story 5.5: Event Feed Component (needs WebSocket client)
- Story 5.6: System Health Display (can proceed in parallel)

## Implementation Guidance

### Step-by-Step Implementation

1. **Create WebSocketManager** (45 minutes)
   - Create `api/websocket.py`
   - Implement connection tracking
   - Implement broadcast logic
   - Implement heartbeat
   - Test: Can add/remove connections

2. **Create WebSocket endpoint** (30 minutes)
   - Create `api/routes/stream.py`
   - Implement `/ws/events` endpoint
   - Handle connect/disconnect
   - Test: Can connect with WebSocket client

3. **Add heartbeat logic** (20 minutes)
   - Implement ping/pong messages
   - Add heartbeat task
   - Test: Clients receive pings

4. **Integrate with EventManager** (45 minutes)
   - Update `core/event_manager.py`
   - Add WebSocket manager parameter
   - Add broadcast call in create_event()
   - Test: Events broadcast to WebSocket

5. **Update FastAPI app** (15 minutes)
   - Add stream router
   - Add startup/shutdown events
   - Test: WebSocket endpoint available

6. **Write unit tests** (90 minutes)
   - Test WebSocketManager methods
   - Test connection lifecycle
   - Test broadcast logic
   - Test error handling

7. **Integration testing** (45 minutes)
   - Test full event flow (camera â†’ WebSocket)
   - Test multiple clients
   - Test reconnection
   - Test server restart

8. **Load testing** (30 minutes)
   - Test 100 simultaneous connections
   - Measure broadcast latency
   - Check memory usage
   - Verify no leaks

### Estimated Effort
- **Implementation:** 4-5 hours
- **Testing:** 2-3 hours
- **Documentation:** 1 hour
- **Total:** 7-9 hours (1 day)

## Testing Requirements

### Unit Tests

```python
# tests/api/test_websocket.py
import pytest
from fastapi.testclient import TestClient
from fastapi import WebSocket
import asyncio

from api.app import create_app
from api.websocket import WebSocketManager

@pytest.fixture
def ws_manager():
    return WebSocketManager()

def test_websocket_connection(ws_manager):
    """Test WebSocket connection tracking."""
    # Mock WebSocket
    class MockWebSocket:
        async def send_json(self, data):
            pass

        async def close(self):
            pass

    ws = MockWebSocket()
    connection_id = ws_manager.connect(ws)

    assert connection_id is not None
    assert ws_manager.get_connection_count() == 1

    ws_manager.disconnect(connection_id)
    assert ws_manager.get_connection_count() == 0

@pytest.mark.asyncio
async def test_broadcast_event(ws_manager):
    """Test event broadcasting to all clients."""
    received_messages = []

    class MockWebSocket:
        async def send_json(self, data):
            received_messages.append(data)

    # Connect 3 clients
    ws1 = MockWebSocket()
    ws2 = MockWebSocket()
    ws3 = MockWebSocket()

    ws_manager.connect(ws1)
    ws_manager.connect(ws2)
    ws_manager.connect(ws3)

    # Broadcast event
    event_data = {"event_id": "evt_123", "description": "Test event"}
    await ws_manager.broadcast_event(event_data)

    # All clients should receive the event
    assert len(received_messages) == 3
    assert all(msg["type"] == "event" for msg in received_messages)
    assert all(msg["data"] == event_data for msg in received_messages)

@pytest.mark.asyncio
async def test_dead_connection_cleanup(ws_manager):
    """Test automatic cleanup of dead connections."""
    class DeadWebSocket:
        async def send_json(self, data):
            raise Exception("Connection dead")

    ws = DeadWebSocket()
    connection_id = ws_manager.connect(ws)

    assert ws_manager.get_connection_count() == 1

    # Broadcast should detect dead connection and clean up
    await ws_manager.broadcast_event({"test": "data"})

    assert ws_manager.get_connection_count() == 0
```

### Integration Tests

```python
# tests/integration/test_websocket_flow.py
import pytest
from fastapi.testclient import TestClient
import json

from api.app import create_app

@pytest.fixture
def client():
    app = create_app()
    return TestClient(app)

def test_websocket_endpoint_exists(client):
    """Test WebSocket endpoint is available."""
    # WebSocket endpoints don't appear in OpenAPI docs by default
    # but we can test the route exists
    with pytest.raises(Exception):
        # TestClient doesn't support WebSocket, but route should exist
        with client.websocket_connect("/ws/events") as websocket:
            pass

# Manual integration test (run with actual WebSocket client)
"""
Manual test with websocat:

# Install websocat
brew install websocat

# Connect to WebSocket
websocat ws://localhost:8000/ws/events

# You should receive ping messages every 30 seconds
# Trigger an event (motion detection) and verify you receive event message
"""
```

### Manual Testing Checklist

- [ ] Start web server: `python web_server.py`
- [ ] Connect with WebSocket client (browser console or websocat)
- [ ] Verify connection established (receives welcome/ping)
- [ ] Trigger event in main application
- [ ] Verify event received via WebSocket within 1 second
- [ ] Connect multiple clients (2-3)
- [ ] Verify all clients receive events
- [ ] Disconnect one client, verify others still work
- [ ] Verify ping messages received every 30 seconds
- [ ] Restart server, verify clients can reconnect
- [ ] Check logs for connection events
- [ ] Verify no memory leaks (long-running test)

## Definition of Done

- [ ] All 12 acceptance criteria met
- [ ] WebSocket endpoint functional at `/ws/events`
- [ ] WebSocketManager implements connection tracking
- [ ] EventManager broadcasts events via WebSocket
- [ ] Heartbeat ping/pong implemented
- [ ] Unit tests written and passing (>80% coverage)
- [ ] Integration tests passing
- [ ] Manual testing checklist complete
- [ ] Load test with 100 connections successful
- [ ] No memory leaks detected
- [ ] Code reviewed and approved
- [ ] Merged to main branch

## Success Metrics

- Broadcast latency: <100ms from EventManager to client
- Memory usage: <10MB per 100 clients
- CPU overhead: <2% for WebSocket operations
- Connection success rate: >99%
- Handles 100 simultaneous connections
- Unit test coverage: >80% for api/websocket.py

## Notes

### WebSocket vs REST API Polling

**WebSocket Benefits:**
- Real-time updates (<1s latency vs 5s polling)
- 95% reduction in server requests
- Lower bandwidth usage
- Better user experience

**WebSocket Challenges:**
- More complex than REST
- Requires async handling
- Connection management overhead
- Reconnection logic needed

### Security Considerations
- WebSocket only accepts localhost connections (same as REST API)
- No authentication in Phase 2 (localhost-only)
- Origin validation to prevent cross-site WebSocket hijacking

### Future Enhancements (Out of Scope for 5.3)
- Message replay for reconnected clients (Epic 6)
- Bidirectional commands (pause/resume) (Epic 6)
- Authentication for remote access (Epic 6)
- Message compression for bandwidth savings (Epic 6)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-10 | 1.0 | Initial story creation | Winston (Architect) |

